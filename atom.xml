<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Helloworldwuyuze&#39;s Blog</title>
  
  <subtitle>May all the beauty be blessed</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-08-11T13:46:57.063Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Wu Yuze</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01-trie 进阶</title>
    <link href="http://example.com/2024/08/11/01trie%20%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2024/08/11/01trie%20%E8%BF%9B%E9%98%B6/</id>
    <published>2024-08-11T13:48:21.000Z</published>
    <updated>2024-08-11T13:46:57.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01-Trie-进阶"><a href="#01-Trie-进阶" class="headerlink" title="01-Trie 进阶"></a>01-Trie 进阶</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>$01-Trie$ 是一类解决有关异或问题的工具。它支持插入、删除、全局 $+1$、求异或和、求最大异或值的问题。</p><h2 id="异或和-01-Trie"><a href="#异或和-01-Trie" class="headerlink" title="异或和 $01-Trie$"></a>异或和 $01-Trie$</h2><h3 id="插入，删除操作"><a href="#插入，删除操作" class="headerlink" title="插入，删除操作"></a>插入，删除操作</h3><p>首先我们明确 $01-Trie$ 的基本形态。它类似于一个动态开点线段树。每个节点有两个儿子 $t_{p,0}$ 和 $t_{p,1}$ 分别表示下一位是 $0&#x2F;1$ 的编号是多少。这里我们的 $Trie$ 树维护的二进制串是从最低位开始的。而我们需要维护三个信息：</p><ul><li>$t_{p,0&#x2F;1}$，表示下一位是 $0&#x2F;1$ 时的儿子编号是多少。这与普通的 $Trie$ 相同。</li><li>$w_p$，表示最后落在 $p$ 子树内的数有多少个。也可以理解为经过 $(p,fa_p)$ 这条边的数的数量。</li><li>$sum_p$，表示 $p$ 子树内的异或和。注意这里以 $p$ 为根节点就不需要考虑 $p$ 以上的部分，也就是原来 $11010$ 的东西现在可能是 $01011,1011,011,11$ 或者 $1$。</li></ul><p>对于最终的异或和的答案，我们只关心在某一条 $1$ 边，它的 $w$ 是多少。因为只有权值是 $1$ 且经过次数为奇数的边才会对答案产生贡献。那么不难想到：</p><p>$$sum_{p}&#x3D;sum_{t_{p,0}}\times2+sum_{t_{p,1}}*2+(w_{t_{p,1}}&amp;1)$$</p><p>这表示左儿子和右儿子的异或和分别乘以二，然后看 $1$ 边的奇偶情况选择加不加。</p><p>于是代码也很简单了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ls(p) t[p][0]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs(p) t[p][1]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">w[p]=sum[p]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">ls</span>(p))w[p]+=w[<span class="built_in">ls</span>(p)], sum[p]^=sum[<span class="built_in">ls</span>(p)]&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">rs</span>(p))w[p]+=w[<span class="built_in">rs</span>(p)], sum[p]^=(sum[<span class="built_in">rs</span>(p)]&lt;&lt;<span class="number">1</span>)|(w[<span class="built_in">rs</span>(p)]&amp;<span class="number">1</span>);</span><br><span class="line">w[p]&amp;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> x,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!p)p=++idx;</span><br><span class="line"><span class="keyword">if</span>(dep&gt;MAXN)<span class="keyword">return</span> (<span class="type">void</span>)(++w[p]);</span><br><span class="line"><span class="built_in">update</span>(t[p][x&amp;<span class="number">1</span>],x&gt;&gt;<span class="number">1</span>,dep+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，删除操作其实和增加没有区别。因为再增加一次就相当于在异或和当中把它删除掉了。</p><h3 id="全局-1"><a href="#全局-1" class="headerlink" title="全局 $+1$"></a>全局 $+1$</h3><p>首先我们观察二进制下加一的规律。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000</span> + <span class="number">1</span> = <span class="number">00001</span></span><br><span class="line"><span class="number">00111</span> + <span class="number">1</span> = <span class="number">01000</span></span><br><span class="line"><span class="number">10101</span> + <span class="number">1</span> = <span class="number">10110</span></span><br></pre></td></tr></table></figure><p>相信大家已经观察出来了，对于某一位 $i$，它 $+1$ 就代表它由 $0\to 1$ 或者 $1\to 0$，而如果它的下一位仍然是 $1$，就继续到下一位进行操作。</p><p>这样就不难得出我们的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">alladd</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="built_in">swap</span>(<span class="built_in">ls</span>(p), <span class="built_in">rs</span>(p));</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">ls</span>(p))<span class="built_in">alladd</span>(<span class="built_in">ls</span>(p));</span><br><span class="line"><span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>其实和线段树的合并都差不多，分为以下几个步骤：</p><ol><li>如果 $p$ 或者 $q$ 为空，就直接返回 $p+q$。( $coduck$祖传)</li><li><code>w[p]+=w[q], sum[p]^=sum[q];</code></li><li>对左、右儿子继续进行合并操作。</li></ol><p>复杂度应该仍然是均摊 $n\log n$。注意这里不需要再 <code>push_up</code> 来更新了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!p||!q)<span class="keyword">return</span> p+q;</span><br><span class="line">w[p]+=w[q], sum[p]^=sum[q];</span><br><span class="line"><span class="built_in">ls</span>(p)=<span class="built_in">merge</span>(<span class="built_in">ls</span>(p),<span class="built_in">ls</span>(q)), <span class="built_in">rs</span>(p)=<span class="built_in">merge</span>(<span class="built_in">rs</span>(p),<span class="built_in">rs</span>(q));</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大异或路径-01-Trie"><a href="#最大异或路径-01-Trie" class="headerlink" title="最大异或路径 $01-Trie$"></a>最大异或路径 $01-Trie$</h2><p>问题是给定序列，求</p><p>$$\max\limits_{i&#x3D;1,j&#x3D;1}^n a_i \oplus a_j$$</p><p>我们考虑枚举 $i$，然后执行下列操作：</p><ul><li>在字典树中查询可以与 $i$ 组成的最大异或和的数，算入答案。</li><li>将 $i$ 插入字典树。</li></ul><p>关键在于如何查询。</p><h3 id="最大异或"><a href="#最大异或" class="headerlink" title="最大异或"></a>最大异或</h3><p>这个 $01-Trie$ 是从最高位开始插入的。我们一般设 <code>MAXN=31</code>。</p><p>插入与普通 $Trie$ 基本一样，但是，在查询的时候，我们需要自己选择路径走。我们设当前查询的数的二进制是 ${b_n}$，于是：</p><ul><li>如果 $t_{p,!b_i}$ 存在，那么进入 $t_{p,!b_i}$ 并且将 <code>1&lt;&lt;dep-1</code> 计入答案。</li><li>否则，如果 $t_{p,b_i}$ 存在，那么进入 $t_{p,b_i}$。</li><li>否则，返回 <code>ans</code>。</li></ul><p>因为我们知道 $\sum\limits_{i&#x3D;1}^n 2^i&lt; 2^{n+1}$，因此我们随时要保证最高位最大才能够保证最后结果最大。因此就有这上述的贪心做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(_2 x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> p=<span class="number">0</span>, dep=<span class="number">31</span>, ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">31</span>;++i, --dep)</span><br><span class="line"><span class="keyword">if</span>(t[p][!x.b[i]])ans+=(<span class="number">1</span>&lt;&lt;dep<span class="number">-1</span>), p=t[p][!x.b[i]];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t[p][x.b[i]])p=t[p][x.b[i]];</span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="01-Trie-做平衡树"><a href="#01-Trie-做平衡树" class="headerlink" title="$01-Trie$ 做平衡树"></a>$01-Trie$ 做平衡树</h2><p>让我们回顾一下 <strong>【模板】普通平衡树</strong>，不难发现，插入、删除和查询区间查排名、拿排名查值的操作，我们的 $01-trie$ 因为有线段树的特性显然这两个可以用线段树的东西也是可以用 $01-trie$ 的。而对于查询前驱和后继，我们直接查询排名为当前值 +1&#x2F;-1 的值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXH = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, op, x, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ADD = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t[N&lt;&lt;<span class="number">5</span>][<span class="number">2</span>], w[N&lt;&lt;<span class="number">5</span>], idx = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=MAXH;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!t[p][(x&gt;&gt;i)&amp;<span class="number">1</span>])t[p][(x&gt;&gt;i)&amp;<span class="number">1</span>] = ++idx;</span><br><span class="line">w[p]+=k;</span><br><span class="line">p = t[p][(x&gt;&gt;i)&amp;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">w[p]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GRBV</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=MAXH;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"><span class="keyword">if</span>(((x&gt;&gt;i)&amp;<span class="number">1</span>))ans += w[t[p][<span class="number">0</span>]];</span><br><span class="line">p = t[p][(x&gt;&gt;i)&amp;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(!p)<span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GVBR</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=MAXH;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line"><span class="keyword">if</span>(w[t[p][<span class="number">0</span>]] &gt;= x)p = t[p][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span>x -= w[t[p][<span class="number">0</span>]], p = t[p][<span class="number">1</span>], ans += (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GVBR</span>(<span class="built_in">GRBV</span>(x)<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nxt</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GVBR</span>(<span class="built_in">GRBV</span>(x+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，有一些需要注意的点：</p><ol><li>因为值域为 $[-10^7, 10^7]$，而 $01-trie$ 处理不了负数，这就需要我们给值域整个加上 $10^7$。</li><li>$idx$ 一定要从 $1$ 开始，否则可能会出现无 左&#x2F;右 儿子但是却仍然会访问到 $0$ 节点导致错误。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;01-Trie-进阶&quot;&gt;&lt;a href=&quot;#01-Trie-进阶&quot; class=&quot;headerlink&quot; title=&quot;01-Trie 进阶&quot;&gt;&lt;/a&gt;01-Trie 进阶&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>整体二分</title>
    <link href="http://example.com/2024/08/11/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"/>
    <id>http://example.com/2024/08/11/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/</id>
    <published>2024-08-11T13:47:21.000Z</published>
    <updated>2024-08-11T13:46:16.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整体二分"><a href="#整体二分" class="headerlink" title="整体二分"></a>整体二分</h1><p>一时间竟然不知道怎么切入，<del>我们不妨按照 $\text{OI-Wiki}$ 的思路引入罢。</del></p><h2 id="静态全局第-k-小"><a href="#静态全局第-k-小" class="headerlink" title="静态全局第 $k$ 小"></a>静态全局第 $k$ 小</h2><h3 id="Ques-1"><a href="#Ques-1" class="headerlink" title="Ques 1"></a>Ques 1</h3><blockquote><p>询问一次全局第 $k$ 小。</p></blockquote><p>这样的解法是简单的。我们可以直接排序然后访问数组第 $k$ 个位置。也可以考虑二分，但二分要求我们快速知道 $\le x$ 的数有多少个，于是我们就可以使用树状数组（离散化）或者线段树（离散化或动态开点）维护即可。</p><p>注意，我们这里称 $kth$ 的算法为 <strong>二分</strong>，这是因为我们二分 $kth$ 是多少，然后再根据 $\sum\limits_{i&#x3D;1}^n[a_i\le mid]$ 来判断是 $l&#x3D;mid$ 还是 $r&#x3D;mid$。因此，区间 $kth$ 的本质是一种二分。</p><h3 id="Ques-2"><a href="#Ques-2" class="headerlink" title="Ques 2"></a>Ques 2</h3><blockquote><p>询问多次全局第 $k$ 小（ $k$ 不同）。</p></blockquote><p>显然，我们仍然可以排个序然后按顺序访问不同的 $k$，但同样，我们可以使用二分的方法。</p><p>考虑到二分答案的本质是把一个问题的答案不断缩小直至可以确定。而对于多个问题，这显然也不是问题。我们可以将这许多次询问放在一起，然后统一枚举一个 $mid$ 作为答案，然后根据 $\sum\limits_{i&#x3D;1}^n[a_i\le mid]$ 的值与 $k$ 的关系将这些问题 <strong>分流</strong>，偏小的分到左边，偏大的分到右边，然后分别继续枚举各自的 $mid$，再继续分流。这其实在本质上就是一种分治的做法，但是仍然具有二分的枚举答案的特点，简称就是将二分与分治结合起来，通过二分得到的反馈来进行分治。因为二分最多分 $\log n$ 层，而每一层又都是只需要处理 $q$ 个问题，故复杂度就是 $q\log n$。</p><h2 id="动态全局第-k-小"><a href="#动态全局第-k-小" class="headerlink" title="动态全局第 $k$ 小"></a>动态全局第 $k$ 小</h2><p>这个显然就不区分多次询问还是一次询问了，但是我们仍然分不同的解法。</p><h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol 1"></a>Sol 1</h3><p>显然，线段树或者平衡树可以很好地解决这个问题。直接在值域线段树上单点修改整体 $kth$ 即可。</p><h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol 2"></a>Sol 2</h3><p>如果我们继续沿着刚刚的思路，把所有的操作放在一起处理，我们能不能解决这个问题呢？</p><p>也许你会说，刚刚是没有修改的，我们放在一起可以全部处理询问，但是如果有了修改，我们怎么样确定修改应该被分到左边还是右边呢？显然有修改是会既影响左边又影响右边的。</p><p>但是，我们回想一下线段树上 $kth$ 的过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[ls[p]] &gt;= k)<span class="keyword">return</span> <span class="built_in">kth</span>(ls[p], l, mid, k);</span><br><span class="line">    <span class="keyword">else</span><span class="keyword">return</span> <span class="built_in">kth</span>(rs[p], mid+<span class="number">1</span>, r, k-s[ls[p]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们悄悄的发现了，如果 $kth$ 到了右子树，我们会把左子树的所有东西都减掉，也就是这里的 <code>k-s[ls[p]]</code>。那么，我们在整体二分的时候，能不能按照同样的思路，如果一个修改的值 $\le mid$，或者说这个修改 $x\ k$ 中 $k\le mid$，它显然也会影响到那些被分到右边的查询，但是如果它们被分到右边，那么就有它们的 $ans&gt;mid$，也就是说，无论如何这里的 $k$ 就只能影响这些询问一次了，因此直接在这里减掉 $1$ 即可。同理，如果一个询问要被分到左边，且有一个修改 $x,k$ 中 $k&gt;mid$，那么因为这询问被分到了左边，因此它的 $ans\le mid$，故无论如何右边的那个修改都与它无缘，它们擦肩而过就分道扬镳，再也见不着了。</p><p>那么在此基础之上，我们保证分到同一边的操作按照编号大小排序（这是不是有点像归并的逆过程），这就保证了在该操作之前的操作一定会先执行，只要它们被分到了一个地方。</p><p>具体地，我们在 <code>solve</code> 函数里面传入参数 <code>L,R,l,r</code>，分别表示操作的左、右端点和目前二分的左、右端点。这样我们令 <code>mid=l+r&gt;&gt;1</code>，作为本次二分的钦定答案。然后：</p><ul><li>对于修改操作：</li><li><ul><li>如果有 $k\le mid$，那么我们就进行这次修改（也就是令一个计数器 <code>+1</code>），并且将它分到左边。</li><li>否则，我们不进行这次修改，将它放到右边。</li></ul></li><li>对于查询操作：</li><li>我们首先看看枚举到这个询问的时候进行了多少次 $\le mid$ 的修改（也就是访问那个计数器），记它为 $t$，然后：</li><li><ul><li>如果有 $t\ge k$，那么，这就说明比 $mid$ 小的数已经比 $k$ 个要多了，这个时候将询问分到左边即可。</li><li>否则，小于等于 $mid$ 仍然满足不了 $k$ 个，那么我们将它分到右边，**并且将 $k$ 减去 $t$**。这就是我们刚刚着重讲的那个点。</li></ul></li></ul><p>至于记录答案，我们直接在 $l&#x3D;r$ 的时候枚举所有的 $i\in [L,R]$，如果 $i$ 操作是询问，就直接把答案赋为 $l$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R &lt; L)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=L;i&lt;=R;++i)</span><br><span class="line">            <span class="keyword">if</span>(op[i].type == <span class="number">2</span>)op[i].ans = l;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>, cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=L;i&lt;=R;++i)</span><br><span class="line">        <span class="keyword">if</span>(op[i].type == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; op[i].c)op[i].c -= cnt, q[++cnt2] = op[i];</span><br><span class="line">            <span class="keyword">else</span>p[++cnt1] = op[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(op[i].c &lt;= mid)++cnt, p[++cnt1] = op[i];</span><br><span class="line">            <span class="keyword">else</span>q[++cnt2] = op[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt1;++i)op[i+L<span class="number">-1</span>] = p[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt2;++i)op[i+L+cnt1<span class="number">-1</span>] = q[i];</span><br><span class="line">    <span class="built_in">solve</span>(L, L+cnt1<span class="number">-1</span>, l, mid), <span class="built_in">solve</span>(L+cnt2, R, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态区间第-k-小"><a href="#静态区间第-k-小" class="headerlink" title="静态区间第 $k$ 小"></a>静态区间第 $k$ 小</h2><p>这里虽然是静态，但是每一次查询的区间并不一样，因此我们需要记录一个类似于前缀和的东西来帮助我们完成这个询问。</p><h3 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h3><p>我们使用动态开点线段树，然后对于每个位置 $i$ 都开一个线段树，它是基于第 $i-1$ 棵线段树的基础上加上一个点产生的。注意到单点修改只会有 $\log n$ 次，然后在查询区间的时候我们使用 $s_r-s_{l-1}$ 的差分方法就可以直接在线段树上求区间 $kth$ 了。 </p><h3 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h3><p>同样地，我们可以使用二分来解决问题。根据上面的思路，我们不难想到这里区间查询的解题思路：</p><p>首先，修改是没有用的，我们直接接着全局静态查询的思路来。全局静态查询需要我们知道全局小于等于它的是多少，但是这里我们改成了区间，这就可以了。如果不能理解，我们可以先考虑如果只有一个询问怎么二分，显然地，我们直接枚举 $mid$ 并询问 $\le mid$ 的有多少个，然后根据这个结果进行缩小区间操作即可。询问多了就把询问分流即可。</p><p>但是我们注意到有一个区间求小于等于某个数的数有多少个，这我们使用树状数组对于每个区间每次加入后再清空，这就显得很冗杂，因为我们明明完全可以在主席书上直接二分来减少一个 $\log$ 的，但是不急，虽然这个方法在现在开起来并不优，但是这方法具有很高的可拓展性。这是因为给定初始数组可以被看做在刚开始进行了 $n$ 次修改。而我们二分的时候把修改放到询问中间来，这就可以完全兼容后面待修的做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">    <span class="type">int</span> b[N];</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> lowbit</span></span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(R &lt; L)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=L;i&lt;=R;++i)</span><br><span class="line">            op[i].ans = l;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>, cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=L;i&lt;=R;++i)</span><br><span class="line">        <span class="keyword">if</span>(op[i].type == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(op[i].c &lt;= mid)<span class="built_in">update</span>(op[i].loca, <span class="number">1</span>), p[++cnt1] = op[i];</span><br><span class="line">            <span class="keyword">else</span>q[++cnt2] = op[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">query</span>(op[i].r) - <span class="built_in">query</span>(op[i].l<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(t &gt;= op[i].c)p[++cnt1] = op[i];</span><br><span class="line">            <span class="keyword">else</span>op[i].c -= t, q[++cnt2] = op[i];</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt1;++i)</span><br><span class="line">        <span class="keyword">if</span>(op[i].type == <span class="number">1</span>)<span class="built_in">update</span>(op[i].loca, <span class="number">-1</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt1;++i)op[i+L<span class="number">-1</span>] = p[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt2;++i)op[i+L+cnt1<span class="number">-1</span>] = q[i];</span><br><span class="line">    <span class="built_in">solve</span>(L, L+cnt1<span class="number">-1</span>, l, mid), <span class="built_in">solve</span>(L+cnt1, R, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，值得注意的是每次进入函数我们需要判断 $R&lt;L$，这是因为如果所有的操作都被分配到一边，那么就会出现 <code>solve(L, L-1, l, mid)</code> 或者 <code>solve(R+1, R, mid+1, r)</code>，如果不进行判断就会产生错误。</p><h2 id="动态区间第-k-小"><a href="#动态区间第-k-小" class="headerlink" title="动态区间第 $k$ 小"></a>动态区间第 $k$ 小</h2><p>于是我们来看看终极问题：<strong>动态区间第 $k$ 小</strong>。这就需要 “<strong>解决动态区间第 $k$ 的三种方法</strong>”。</p><h3 id="Sol1"><a href="#Sol1" class="headerlink" title="Sol1"></a>Sol1</h3><p>我们仍然可以使用数据结构草过去。但是这次的数据结构就十分高级了：树套树。</p><p>这里，我们使用树状数组套线段树。</p><h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><p>因为外层是树状数组，我们在 $x$ 这个地方把 $a_x$ 变为 $y$ 这个操作，会影响到所有在 <code>for(int i=x;i&lt;=n;i+=lowbit(i))</code> 这个语句中遍历到的 $i$，因此，在这些地方我们都需要对线段树进行修改。具体地，这个线段树是值域线段树，我们把原来的 $a_x$ 删除，然后再加上 $y$ 即可。因此，一次操作需要操作 $\log n$ 次线段树，也就是复杂度为 $O(\log ^2 n)$。</p><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><p>同样地，根据树状数组的定义，我们想要知道 $[1,r]$ 中有多少个数，我们就需要加上所有 <code>for(int i=r;i;i-=lowbit(i))</code> 语句遍历到的 $i$ 所在线段树的数。然后，我们还要知道 $[1,l-1]$ 有多少个数，把上面的 $r$ 改成 $l-1$ 即可。然后我们把这两个值相减，就能够得到当前的节点上 $[l,r]$ 有多少个数。</p><p>于是，我们仍然在线段树上二分，但是我们这次同时在 $2\log n$ 棵线段树上进行二分，然后每一次我们需要知道它们的左儿子有多少个数，于是我们需要 $O(\log n)$ 求出这个 $sum$ 来跟 $k$ 作比较。这就完成了一次二分的过程，然后我们就直接继续二分即可。这样，一次查询的复杂度就是 $O(log^2 n)$ 的。</p><p>这样，我们就得到了一个 $O((n+q)log^2 n)$ 的优秀做法。它本质上是使用外层的树状数组来维护数列，然后内层线段树来完成查询操作。但是，它的空间复杂度实在是太高了，因为有可能有 $O(n)$ 次修改，然后我们每一次需要修改 $O(\log n)$ 棵线段树，每棵线段树有可能修改 $O(\log n)$ 个节点，这样空间复杂度达到了 $O(n\log ^2 n)$，令我无法接受（当然题目可以接受）。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, a[N], b[N&lt;&lt;<span class="number">1</span>], m, cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">opt</span>&#123;</span><br><span class="line"><span class="type">char</span> type;</span><br><span class="line"><span class="type">int</span> l, r, k;</span><br><span class="line">&#125;op[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> root[N], s[N&lt;&lt;<span class="number">7</span>], ls[N&lt;&lt;<span class="number">7</span>], rs[N&lt;&lt;<span class="number">7</span>], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!p)p = ++idx;</span><br><span class="line">s[p] += k;</span><br><span class="line"><span class="keyword">if</span>(l == r)<span class="keyword">return</span> ;</span><br><span class="line"><span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= mid)<span class="built_in">update</span>(ls[p], l, mid, x, k);</span><br><span class="line"><span class="keyword">else</span><span class="built_in">update</span>(rs[p], mid+<span class="number">1</span>, r, x, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line"><span class="built_in">update</span>(root[i], <span class="number">1</span>, cnt, v, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n1, n2, t1[N], t2[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)<span class="keyword">return</span> l;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;++i)sum -= s[ls[t1[i]]];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)sum += s[ls[t2[i]]];</span><br><span class="line"><span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sum &lt; k)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;++i)t1[i] = rs[t1[i]];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)t2[i] = rs[t2[i]];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">kth</span>(mid+<span class="number">1</span>, r, k - sum);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;++i)t1[i] = ls[t1[i]];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n2;++i)t2[i] = ls[t2[i]];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">kth</span>(l, mid, k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">n1 = n2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=r;i;i-=<span class="built_in">lowbit</span>(i))t2[++n2] = root[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>;i;i-=<span class="built_in">lowbit</span>(i))t1[++n1] = root[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)cin&gt;&gt;a[i], b[++cnt] = a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">cin&gt;&gt;op[i].type;</span><br><span class="line"><span class="keyword">if</span>(op[i].type == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">cin&gt;&gt;op[i].l&gt;&gt;op[i].k;</span><br><span class="line">b[++cnt] = op[i].k;</span><br><span class="line">&#125;<span class="keyword">else</span>cin&gt;&gt;op[i].l&gt;&gt;op[i].r&gt;&gt;op[i].k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(b+<span class="number">1</span>, b+<span class="number">1</span>+cnt);</span><br><span class="line">cnt = <span class="built_in">unique</span>(b+<span class="number">1</span>, b+<span class="number">1</span>+cnt) - b - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i] = <span class="built_in">lower_bound</span>(b+<span class="number">1</span>, b+<span class="number">1</span>+cnt, a[i]) - b;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line"><span class="keyword">if</span>(op[i].type == <span class="string">&#x27;C&#x27;</span>)op[i].k = <span class="built_in">lower_bound</span>(b+<span class="number">1</span>, b+<span class="number">1</span>+cnt, op[i].k) - b;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">modify</span>(i, a[i], <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(op[i].type == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">modify</span>(op[i].l, a[op[i].l], <span class="number">-1</span>);</span><br><span class="line">a[op[i].l] = op[i].k;</span><br><span class="line"><span class="built_in">modify</span>(op[i].l, a[op[i].l], <span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span><span class="built_in">init</span>(op[i].l, op[i].r, op[i].k), cout&lt;&lt;b[<span class="built_in">kth</span>(<span class="number">1</span>, cnt, op[i].k)]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>代码还是不难写的。</del></p><h3 id="Sol2"><a href="#Sol2" class="headerlink" title="Sol2"></a>Sol2</h3><p>另外，如果你十分熟悉 $\text{Ynoi}$ 的题目，这道题可以使用分块来完成。</p><p><del>谁说就没有分块套分块呢。</del></p><p>按照树套树的思路，我们来一个分块套分块就可以了，具体地细节我还没写（bushi。</p><h3 id="Sol3"><a href="#Sol3" class="headerlink" title="Sol3"></a>Sol3</h3><p>整体二分。我们直接将第二个问题：动态区间 $kth$ 中的操作改一下，再查询中加入修改操作即可。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;整体二分&quot;&gt;&lt;a href=&quot;#整体二分&quot; class=&quot;headerlink&quot; title=&quot;整体二分&quot;&gt;&lt;/a&gt;整体二分&lt;/h1&gt;&lt;p&gt;一时间竟然不知道怎么切入，&lt;del&gt;我们不妨按照 $&#92;text{OI-Wiki}$ 的思路引入罢。&lt;/del&gt;&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2024 SDSC Day 5 Sol</title>
    <link href="http://example.com/2024/08/11/2024SDSC%20Day%205%20Sol/"/>
    <id>http://example.com/2024/08/11/2024SDSC%20Day%205%20Sol/</id>
    <published>2024-08-11T13:46:21.000Z</published>
    <updated>2024-08-11T13:48:34.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Summer-Camping-Day-5-Sol"><a href="#Summer-Camping-Day-5-Sol" class="headerlink" title=" Summer Camping Day 5 Sol "></a><center> Summer Camping Day 5 Sol </center></h1><h2 id="A-shark"><a href="#A-shark" class="headerlink" title="A.shark"></a>A.shark</h2><h3 id="Des"><a href="#Des" class="headerlink" title="Des"></a>Des</h3><p>给定两个序列 $a$ 与 $b$，其中可以对 $a$ 序列进行操作 $a_i\leftrightarrow a_j(i\not &#x3D; j)$，使得最小化：</p><p>$$<br>\sum_{i&#x3D;1}^n (a_i-b_i)^2<br>$$</p><p>求这个最小化的值和在保证这个值最小化的情况下的最小操作次数。保证 $\forall i, j$ 有 $a_i \not &#x3D; a_j$ 且 $b_i\not &#x3D; b_j$。</p><h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>我们不妨考虑对于一对 $(i,j)$。不妨设：<br>$$<br>\begin{cases}a_i&lt; a_j\b_i&lt;b_j\end{cases}<br>$$<br>那么，有：<br>$$<br>\begin{aligned}<br>(a_i-b_i)^2+(a_j-b_j)^2<br>&amp;&#x3D;a_i^2+a_j^2+b_i^2+b_j^2-2a_ib_i-2a_jb_j\<br>&amp;\le a_i^2+a_j^2+b_i^2+b_j^2-2a_ib_j-2a_jb_i\<br>&amp;&#x3D;(a_i-b_j)^2+(a_j-b_i)^2<br>\end{aligned}<br>$$<br>其中不等式为排序不等式。</p><p>于是我们证明了顺序大于乱序。这样，不难得出最小的就是将 $a_i$ 和 $b_i$ 排序之后一一匹配。然后我们考虑如何计算交换次数。注意到题目中说 $a_i\not &#x3D;a_j,b_i\not &#x3D;b_j$，于是，每个数都有且仅有一个位置作为可能的目标位置。于是，我们使用并查集，如果有 $i$ 的目标位置为 $f_i$，则将 $f_i$ 与 $i$ 合并即可。最后答案就是 $n$ 减去独立并查集的数量。</p><h2 id="B-housekeep"><a href="#B-housekeep" class="headerlink" title="B.housekeep"></a>B.housekeep</h2><h3 id="Des-1"><a href="#Des-1" class="headerlink" title="Des"></a>Des</h3><p>给定 $n$ 个物品，其中第 $i$ 个物品有属性 $x_i,y_i$，接下来 $m$ 天每天有一个操作 $op,x$ 表示 加入&#x2F;删除 一个 $x$ 物品。其中物品 $i$ 若在 $j$ 天被加入，则会每隔 $x_i$ 天产生一段连续的 $y_i$ 的贡献。保证每天物品集合无重。求每天操作完之后有多少个物品产生了贡献。</p><h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol"></a>Sol</h3><h4 id="Part-one"><a href="#Part-one" class="headerlink" title="Part one"></a>Part one</h4><p>首先，我们看看当 $x_i+y_i$ 很大的时候怎么做。</p><p>显然，$x_i+y_i$ 是有周期的，是在 $x_i+y_i$ 的后 $y_i$ 天区间加 $1$。如果我们使用差分数组进行维护，那么我们一共会用 $O(1)$ 进行 $\frac{n}{x_i+y_i}$ 次，复杂度 $O(\frac{n}{x_i+y_i})$。看起来很暴力，但是数据大了之后跑得也不慢。</p><h4 id="Part-two"><a href="#Part-two" class="headerlink" title="Part two"></a>Part two</h4><p>现在，我们考虑 $x_i+y_i$ 很小的时候。这个时候，我们发现 $x_i+y_i$ 的取值不是很多，而我们又注意到这个加法是有周期的，也就是每 $x_i+y_i$ 个为一个周期，这样，我们可以开一个 $O(b^2)$ 的数组存储对于 $x_i+y_i$ 的值为 $b$ 时，周期内的每个点到底应该贡献多少。然后我们对于每个 $i$ 时刻，我们暴力将 $b$ 个周期内的 $i$ 应该在的数加起来就能够贡献到 $i$ 了。</p><p>具体地，我们设数组 $cnt_{i,j}$ 表示 $x+y&#x3D;i$ 时 $i\bmod (x+y)&#x3D;j$ 时应该贡献多少。这样，我们在每个 $i$ 时刻操作完之后遍历数组的第一维 $j$ 然后加上 $cnt_{j,i\bmod j}$ 即可。</p><h4 id="Part-three"><a href="#Part-three" class="headerlink" title="Part three"></a>Part three</h4><p>考虑怎么将上面的两种算法融合起来。我们已经知道，第一部分的复杂度为 $O(\frac{n}{x+y})$。第二部分的复杂度为 $O((x+y)^2)$。我们计 $b&#x3D;x+y&#x3D;\sqrt n$，那么对于 $x+y\le b$ 的部分，我们使用 Part two 的算法进行维护，否则使用 Part one 的算法进行维护，这样就能够平衡复杂度。这样，两个东西的复杂度就都变成了 $n\sqrt n$，完全可以通过。</p><p>像这样，将两个暴力的复杂度进行根号平衡的算法，我们称为 <strong>根号分治</strong>。通过根号分治，我们以将两个复杂度分别不对的东西结合起来使得复杂度正确。特别是对于小的那一部分是有规律的情况下，这种做法就完全可以完成。</p><h2 id="C-electric"><a href="#C-electric" class="headerlink" title="C.electric"></a>C.electric</h2><h3 id="Des-2"><a href="#Des-2" class="headerlink" title="Des"></a>Des</h3><p>给定序列 $a_n$，$q$ 次询问 $l,r$ 求：<br>$$<br>\min\limits_{l\le i,j\le r}a_i\mid a_j<br>$$</p><h3 id="Sol1"><a href="#Sol1" class="headerlink" title="Sol1"></a>Sol1</h3><p>看到按位的操作，我们首先想到 $01-trie$，但是我们只知道 $01-trie$ 可以处理最小异或和，却不知道怎么求最小或值。</p><p>其实这个操作也不难。考虑我们现在到达了 $01-trie$ 上的一个节点 $x$，如果 $x$ 到 $0$ 的那条边的儿子数量超过两个，那么显然这一位是可以为 $0$ 的，而我们又是从最高位到最低位进行处理的，所以我们一定要使得这一位最小，因此进入 $0$ 的子树即可。对于 $0$ 子树没有的情况，无论如何这一位都不能变成 $0$ 了，因此加上 $1$ 之后进入 $1$ 子树即可。</p><p>而重点是 $0$ 子树只有一个的情况。这个时候这一位也不可能为 $0$，但是我们却不能够舍去那个这一位为 $0$ 的点。怎么办呢，考虑到我们从上往下求解只会经过 $\log v$ 次 “抉择” ，因此，这种情况也最多遇到 $O(\log v)$ 次，于是我们把这些东西使用 <code>vector</code> 存储下来即可。</p><h3 id="Sol2"><a href="#Sol2" class="headerlink" title="Sol2"></a>Sol2</h3><p>首先给出结论：<br>$$<br>\min\limits_{l\le i,j\le r}a_i\mid a_j&#x3D;\min\limits_{1\le i,j\le \log v}a_{rk_i}\mid a_{rk_j}<br>$$<br>也就是说，我们找出这个区间的前 $32$ 小然后暴力匹配即可。</p><p>结合上面的做法，我们发现这 $32$ 小其实就是我们舍去了的那些只有一个 $0$ 的子树。于是你就完全理解了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Summer-Camping-Day-5-Sol&quot;&gt;&lt;a href=&quot;#Summer-Camping-Day-5-Sol&quot; class=&quot;headerlink&quot; title=&quot; Summer Camping Day 5 Sol &quot;&gt;&lt;/a&gt;&lt;center&gt; Sum</summary>
      
    
    
    
    
    <category term="题解笔记" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Beakjoon19523 Sol</title>
    <link href="http://example.com/2024/08/11/Beakjoon19523/"/>
    <id>http://example.com/2024/08/11/Beakjoon19523/</id>
    <published>2024-08-11T13:46:21.000Z</published>
    <updated>2024-08-11T13:48:59.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Beakjoon19523"><a href="#Beakjoon19523" class="headerlink" title="Beakjoon19523"></a>Beakjoon19523</h1><h2 id="Des"><a href="#Des" class="headerlink" title="Des"></a>Des</h2><p>给定一个 $h\times w$ 的矩阵，初始你处在 $(0,0)$ 的地方，每次你可以进行两个操作：</p><ul><li>$(x,y)\to ((x+1)\bmod h,y)$</li><li>$(x,y)\to (x,(y+1)\bmod w)$</li></ul><p>现在需要你求出对于每个点分配一个方向，求出其中有多少种是可以从 $(0,0)$ 经过所有的点恰好一次走回 $(0,0)$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>于是，我们现在考虑，如果某个点 $(x,y)$ 确定了一定往下走，那么是不是对于点 $(x+1, y-1)$ 和 $(x-1, y+1)$ 也都确定了是往下走的。这是因为我们知道 $(x,y)\to (x,y+1)$，那么 $(x+1,y)$ 就只能通过 $(x+1,y-1)$ 走到。</p><p>继续把这个推广下去，我们会发现，对于任意的 $(x,y)$，只要与它处于一条对角线上，都会和它方向相同。而这里，对角线的概念有所不同，这里我们定义只要满足：</p><p>$$<br>\begin{cases}x+d\equiv x\pmod{h}\y-d\equiv y\pmod w\end{cases}<br>$$</p><p>这就等价于：</p><p>$$<br>\begin{cases}d\equiv 0\pmod h\d\equiv 0\pmod w\end{cases}\Leftrightarrow \begin{cases}h\mid d\w\mid d\end{cases}<br>$$</p><p>也就是说，这里 $d$ 存在最小正整数解，且这个解等于 $\operatorname{lcm}(h,w)$。这就表明，每个对角线的长度都是 $\operatorname{lcm}(h,w)$ 的，而显然，一个点只会属于一条对角线，这是因为对角线的不同等价于点 $(x,y)$ 的坐标和 $x+y$ 在模意义下的不同。因此，就一共有 $\frac{h\times w}{\operatorname{lcm}(h,w)}&#x3D;\gcd(h,w)$ 的不同。</p><p>这样，我们就知道了，对于一个矩阵 $h\times w$，我们可以选择的地方一共有 $2^{\gcd(h,w)}$ 种。现在我们考虑怎么做是合法的。</p><p>首先，需要注意的是，我们有操作 $(x,y)\to(x+1, y)$ 和 $(x,y)\to (x,y+1)$ 这两种操作，除了 $g&#x3D;1$（下面记 $g&#x3D;\gcd(h,w)$）的情况，$x+y\pmod g$ 一定不等于 $x+y+1\pmod g$。也就是说，我们走一步一定从一条对角线走到另一条对角线。那么，我们假设 $(0,0)$ 处在对角线 $1$，那么它一定是经过对角线 $2,3,\dots, g$ 直到返回 $1$。于是，如果我们设这 $g$ 条对角线有 $k$ 条是往下的，那么往右的有 $g-k$ 条，且如果能从 $(x, y)$ 够走回 $(x,y)$，一定有式子：</p><p>$$<br>\begin{aligned}x+d\times k&amp;\equiv x\pmod h\y+d\times(g-k)&amp;\equiv y\pmod w\end{aligned}<br>$$</p><p>将 $(0,0)$ 带入或直接化简，有：</p><p>$$<br>\begin{aligned}d\times k&amp;\equiv 0\pmod h\d\times(g-k)&amp;\equiv0\pmod w\end{aligned}<br>$$</p><p>对于这个同余方程，其实就是：</p><p>$$<br>\begin{aligned}h&amp;\mid d\times k\w&amp;\mid d\times(g-k)\end{aligned}<br>$$</p><p>显然可以看出有一组解：</p><p>$$<br>d&#x3D;\operatorname{lcm}(\frac{h}{\gcd(h,k)},\frac{w}{\gcd(w,g-k)})<br>$$</p><p>显然，因为对角线一共有 $g$ 条，我们要经过所有的及诶单，一定有轮数 $d&#x3D;\operatorname{lcm}(h,w)$。也即我们上面求出的 $d$ 如果与最小公倍数相等就可以加入贡献否则就不能，而贡献也很简单，就是：</p><p>$$<br>\sum_{i&#x3D;0}^g [d&#x3D;\operatorname{lcm}(h,w)]\times \binom{g}{k}<br>$$</p><p>于是这场酣畅淋漓的解体盛宴就完成了！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Beakjoon19523&quot;&gt;&lt;a href=&quot;#Beakjoon19523&quot; class=&quot;headerlink&quot; title=&quot;Beakjoon19523&quot;&gt;&lt;/a&gt;Beakjoon19523&lt;/h1&gt;&lt;h2 id=&quot;Des&quot;&gt;&lt;a href=&quot;#Des&quot; c</summary>
      
    
    
    
    
    <category term="题解笔记" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>莫队</title>
    <link href="http://example.com/2024/08/11/MoTeam/"/>
    <id>http://example.com/2024/08/11/MoTeam/</id>
    <published>2024-08-11T13:46:21.000Z</published>
    <updated>2024-08-11T13:50:06.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="莫队"><a href="#莫队" class="headerlink" title=" 莫队 "></a><center> 莫队 </center></h1><h4 id="——优雅的暴力"><a href="#——优雅的暴力" class="headerlink" title=" ——优雅的暴力 "></a><p align = "right"> ——优雅的暴力 </p></h4><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>对于区间操作问题，如果我们并 <strong>不需要在线（重点！）</strong>，并且我们可以快速地完成下面四个区间转换操作：</p><p>$$(l,r)\to (l+1,r)$$</p><p>$$(l,r)\to (l, r+1)$$</p><p>$$(l,r)\to (l-1, r)$$</p><p>$$(l,r)\to (l,r-1)$$</p><p>那么我们就可以通过对处理区间的顺序进行重新排列，那么我们就可以在 $O(n\sqrt n)$ 的复杂度内完成全部区间操作。</p><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>对于一些询问区间 $[l_i, r_i]$，加入我们把这些询问看成平面直角坐标系上的点，$l_i$ 对应横坐标，$r_i$ 对应纵坐标，那么我们可以画出一张图：</p><p><img src="/./MT1.png"></p><p>然后我们按照横坐标分块，取块长为 $B$：</p><p><img src="/./MT2.png"></p><p>在每个块内，按照纵坐标排序。显然，我们要转移的步数就是两点之间的曼哈顿距离。于是我们可以画出转移的路径：</p><p><img src="/./MT3.png"></p><p>乍一看感觉我们需要更新的路径非常长，但是我们仔细分析就会发现复杂度极其正确。</p><p>首先，对于块内，横坐标的移动距离一次一定不超过块长，也就是说移动一次横坐标一定是 $O(B)$ 的复杂度。而对于纵坐标，因为我们已经从小到大排序了，因此在一个块内走的复杂度是 $O(N)$。块之间横坐标复杂度仍然不变，纵坐标复杂度也是 $O(N)$，因此我们需要 $O(NB+\frac{N^2}{B})$，显然当 $B &#x3D; \sqrt N$ 的时候取到最小值，即复杂度为 $O(N\sqrt N)$。</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><h4 id="卡常技巧"><a href="#卡常技巧" class="headerlink" title="卡常技巧"></a>卡常技巧</h4><p>注意到，普通莫队的重要操作是移动区间，那么这里会分为四个子问题，即向四个不同的方向转移。这个我们可以写成函数来分别完成，但注意卡常的时候尽量不要写成函数。</p><h4 id="区间操作顺序"><a href="#区间操作顺序" class="headerlink" title="区间操作顺序"></a>区间操作顺序</h4><p>另外，四种操作的顺序仍需注意。如果遇到区间 $r&lt;l$，就会在某些情景下造成不合法。因此我们总是先对 $l,r$ 端点进行拓张操作，即：</p><p>$$(l,r)\to \begin{cases}(l-1, r)\(l,r+1)\end{cases}$$</p><p>然后再进行缩区间操作：</p><p>$$(l,r)\to\begin{cases}(l+1,r)\(l,r-1)\end{cases}$$</p><h4 id="莫队配合分块"><a href="#莫队配合分块" class="headerlink" title="莫队配合分块"></a>莫队配合分块</h4><p>在进行操作的时候，如果我们不能够做到 $O(1)$ 修改或查询，那我们可以考虑使用分块。对于单点修改操作，显然对于分快来说大部分都是 $O(1)$，而对于查询操作，分块的复杂度是 $O(\sqrt n)$。而查询只有 $m$ 个。这样正好分块与莫队在 查询&#x2F;修改 时 <strong>取长补短</strong>，完成了根号算法的完美融合。最终复杂度 $O((n+m)\sqrt n)$。</p><h4 id="奇偶优化"><a href="#奇偶优化" class="headerlink" title="奇偶优化"></a>奇偶优化</h4><p>在块间转移的时候，显然我们并不需要每次从最上方转移到最下方。我们只需要对于奇数块从小到大排列 $r$，偶数块从大到小排列 $r$，这样在奇偶交界的时候就可以少一些转移。</p><h2 id="普通莫队经典例题"><a href="#普通莫队经典例题" class="headerlink" title="普通莫队经典例题"></a>普通莫队经典例题</h2><h3 id="P1972-SDOI2009-HH的项链"><a href="#P1972-SDOI2009-HH的项链" class="headerlink" title="P1972 [SDOI2009] HH的项链"></a><a href="https://www.luogu.com.cn/problem/P1972">P1972 [SDOI2009] HH的项链</a></h3><p>求区间内不同的数的个数。</p><p>考虑已知一个区间 $(l,r)$，如何修改区间。</p><p>对于每个权值，我们开一个桶记录出现了多少次。如果由 $0\to 1$，我们就给答案加一；如果 $1\to 0$，就给答案减一。</p><p>但是这么做对于 $10^6$ 的数据显然过不去。这时候我们想起了树状数组怎么做这个题。也就是说，对于一个数 $a_i$，我们记录 $lst_{a_i}$ 表示 $a_i$ 上一次出现在哪。而对于询问 $l,r$，我们只需要统计 $l,r$ 中出现的且上一次出现在 $[1,l)$ 的数的个数。使用莫队维护这个东西即可。</p><h2 id="莫队进阶"><a href="#莫队进阶" class="headerlink" title="莫队进阶"></a>莫队进阶</h2><h3 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h3><p>如果在查询中混入了修改操作，那么问题会变得稍许棘手。</p><p>这样我们需要额外维护一个时间纬度 $t$，表示该询问是进行了多少次修改操作之后进行的。这样我们得到了一个三元组 $(l,r,t)$。我们对三元组的前两元 $l$ 和 $r$ 分块，然后按照 $l$ 所在块为第一关键字、$r$ 所在块为第二关键字、$t$ 为第三关键字进行排序。这样得到的东西跑完之后复杂度是 $O(n^{\frac{5}{3}})$（虽然但是我不会证）。</p><p>于是乎，我们又需要进行一个新的操作：修改。</p><p>我们需要把时间维度调整到我们需要的 $t$，这就需要两个操作：增加操作和撤销操作。对于修改操作，我们直接根据题意修改即可，但一定要注意如果进行修改需要考虑贡献需不需要加入到最终的答案当中。这就需要我们判断修改的点在不在当前询问范围之内。在修改完成之后，我们交换修改值和要修改的值，这样就能够在下次重新进行撤销操作的时候得到正确的修改值。</p><h3 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h3><p>对于树上路径问题，我们仍然可以通过某些算法转换成莫队的问题。</p><h4 id="前置知识：括号序列"><a href="#前置知识：括号序列" class="headerlink" title="前置知识：括号序列"></a>前置知识：括号序列</h4><p>在一棵树上，我们从根节点开始进行 <code>dfs</code>，那么每个节点会有一次入栈操作和一次出栈操作。那么，我们重新开一个栈，在入栈和出栈的时候都将该节点弹入新的栈中，那么得到的栈就是该树的一个括号序列。</p><p>例如下图：</p><p><img src="/./MT4.png"></p><p>根节点是 $1$，那么根绝节点编号决定遍历顺序，那么该树的括号序列就是这样：$1,2,2,4,8,8,4,3,5,5,6,6,7,7,3,1$。现在任取两点，如 $(6,8)$，首先判断它们是不是祖先儿子的关系，发现不是之后直接取 $8$ 出栈到 $6$ 入栈中间的序列，即 $8,4,3,5,5,6$，于是我们发现，只出现了一次的点都是路径上的节点，而出现两次的则不是。另外，它们的最近公共祖先 $1$ 也不在序列内，这需要特殊处理。</p><p>再比如 $(1,7)$，发现它们是祖先儿子关系，于是取 $1$ 入栈到 $7$ 入栈的区间，即 $1,2,2,4,8,8,4,3,5,5,6,6,7$，发现仍然是所有的只出现一次的点都在路径上。而且这时它们的最近公共祖先 $1$ 也在路径上。</p><h4 id="假·树上莫队"><a href="#假·树上莫队" class="headerlink" title="假·树上莫队"></a>假·树上莫队</h4><p>于是，根据括号序列，我们就可以求出树上路径所对应的一个区间，在这些区间上我们使用莫队维护即可。具体地，我们开一个 <code>appear[N]</code> 表示在序列中某个点是否出现。每次遇到括号序列的一个点的时候修改一下 <code>appear</code> 的值即可，如果是 $1$ 则加上贡献，否则减去贡献。</p><p>这个东西不能够叫做严格的树上莫队，但是仍然可以解决大部分问题。</p><h3 id="压位-text-Trie"><a href="#压位-text-Trie" class="headerlink" title="压位 $\text{Trie}$"></a>压位 $\text{Trie}$</h3><h4 id="——这是一个比-set-优秀的平衡树"><a href="#——这是一个比-set-优秀的平衡树" class="headerlink" title=" ——这是一个比 $set$ 优秀的平衡树 "></a><p align = "right"> ——这是一个比 $set$ 优秀的平衡树 </p></h4><p>考虑一个 <strong>64 叉树</strong>，显然，对于一个正常值域的操作，没往上会除以 $64$ 的大小，因此一般 $2^{20}$ 的 $\log$ 可以优化到 $2^4$，即 $O(4)$ 的复杂度。而且在期间操作还都是位运算操作巨快，可以认为是 $O(1)$ 做到加入、删除、查找前驱后继。于是乎，一些与序列位置有关的莫队就会变得非常简单。</p><h3 id="回滚莫队"><a href="#回滚莫队" class="headerlink" title="回滚莫队"></a>回滚莫队</h3><p>考虑如果有操作不好考虑删除但添加简单，或者不好添加但是删除简单，我们就可以使用回滚莫队。</p><p>回滚莫队的本质是尽量减少需撤销的操作次数，于是，根据我们的定义，可以进行一部分可接受的劣化，以达到减少撤销次数的目的：</p><p>首先，我们枚举块，接下来之操作左端点在块内的区间。</p><p>显然，如果右端点也在这个块里面，我们就直接暴力求出答案。这是因为长度小于 $\sqrt n$ 的区间暴力加起来也最多是 $n\sqrt n$ 的复杂度，完全可以接受。而对于右端点不在区间内的，我们先初始化 $l,r$ 为该块的右端点，然后向右拓展 $r$。而对于左端点，因为刚开始在块的右端点，因此需要向左拓展。这就保证了这操作只需要加。</p><p>在处理完这个区间之后，右端点不需要再加操作，因为右端点已经排序。而左端点需要 <strong>滚回</strong> 块的右端点。这就需要我们记录一下左端点的影响然后一步步撤销了。</p><p>具体地，我们进行以下操作；</p><ul><li>枚举块的编号 $i$ 并将左端点初始化为块的右端点 $+1$，右端点初始化为左端点 $-1$。</li><li><ul><li>接着，我们进入内层循环枚举询问的编号 $j$ 使得询问的左端点在块内。</li></ul></li><li><ul><li>如果一个区间在整个块内，我们暴力维护。</li></ul></li><li><ul><li>然后，因为右端点在一个块内一定单调不降（<strong>注意回滚莫队不能够使用奇偶排序</strong>），因此一定不会有右端点的撤回操作，我们直接将右端点更新到目前的查询右端点即可。</li></ul></li><li><ul><li>对于左端点，我们不断向左拓展并且记录操作，以方便在回滚时候的撤销。</li></ul></li></ul><p>这时候我们分析复杂度，右端点每个块内是 $O(n)$，左端点每个询问是 $O(B)$，暴力处理的询问每个是 $O(B)$。因此总复杂度为 $O(\frac{n}{B}n+mB)$，$n,m$ 同阶时 $B$ 取 $\sqrt n$ 即可。</p><h3 id="text-bitset"><a href="#text-bitset" class="headerlink" title="$\text{bitset}$"></a>$\text{bitset}$</h3><p>这个比较抽象，我们直接看一个例题：</p><blockquote><p>给定序列 $a_n$，一次询问描述为 $op,l,r,x$，表示：</p><ul><li>$op&#x3D;1$ 时询问 $l,r$ 内是否存在 $i,j$ 使得 $a_i-a_j&#x3D;x$。</li><li>$op&#x3D;2$ 时询问 $l,r$ 内是否存在 $i,j$ 使得 $a_i+a_j&#x3D;x$。</li><li>$op&#x3D;3$ 时询问 $l,r$ 内是否存在 $i,j$ 使得 $a_i\times a_j&#x3D;x$。</li></ul></blockquote><p>显然一般地莫队并不好维护，但是如果我们对所有的点 出现&#x2F;没出现 维护一个 $\text{bitset}$，然后开始操作：</p><p>对于 $a_i-a_j&#x3D;x$，于是有 $a_j&#x3D;a_i-x$，因此，如果 $i$ 位置有一个数，只需要在 $i-x$ 的位置也有一个数即可使得 $a_i-a_j&#x3D;x$。于是，只要这个 <code>bitset&lt;N&gt; f</code> 有 <code>f&amp;(f&gt;&gt;x)</code> 就能使得这个询问成立。</p><p>对于 $a_i+a_j&#x3D;x$，这时候需要有 $a_j&#x3D;x-a_i$，这时候发现有一个 $-a_i$，因此我们需要维护一个 $b_i&#x3D;maxn-a_i$ 的 $\text{bitset}$，相当于把原来的倒转过来。这时候，就有 $x-a_i&#x3D;x+b_i-maxn&#x3D;b_i+(maxn-x)$，也就是说，只需要给 <code>bitset&lt;N&gt; b</code> 左移 $maxn-x$ 位即可。</p><p>最后一个操作就比较简单，因为操作次数只有 $O(m)$，直接 $\sqrt n$ 枚举因子，判断 $i,\frac{x}{i}$ 是不是都在即可。</p><h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><h3 id="Count-on-a-Tree-II"><a href="#Count-on-a-Tree-II" class="headerlink" title="Count on a Tree II"></a>Count on a Tree II</h3><p>给定一棵树和点的颜色，求一条路径上的颜色数量。</p><p>这个显然可以用 <strong>假·树上莫队</strong> 维护。具体地，我们维护括号序列，然后再开一个颜色数量统计和一个区间内出现与否，这样，在更新的时候我们直接记录一个 <code>appear[N]</code> 数组表示 $x$ 有没有出现过，直接异或即可。<del>（主要是看看莫队代码）</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, a[N], x[N], y[N], nn, sum, ans[N], b[N], col[N];</span><br><span class="line"><span class="type">bool</span> appear[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> l, r, id, x, y;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;other) <span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l/nn == other.l/nn)  <span class="keyword">return</span> (l/nn%<span class="number">2</span>)?r&gt;other.r:r&lt;other.r;</span><br><span class="line"><span class="keyword">return</span> l/nn &lt; other.l/nn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">20</span>], st[N], top, t, in[N], out[N], dep[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fat)</span></span>&#123;</span><br><span class="line">fa[x][<span class="number">0</span>] = fat; st[++top] = x, in[x] = top;</span><br><span class="line">dep[x] = dep[fat] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;++i)   fa[x][i] = fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y:g[x])</span><br><span class="line"><span class="keyword">if</span>(y!=fat)  <span class="built_in">dfs</span>(y, x);</span><br><span class="line">st[++top] = x, out[x] = top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(appear[x] ^= <span class="number">1</span>)sum += ((++col[a[x]]) == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span>sum -= ((--col[a[x]]) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[x] &lt; dep[y])<span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=t;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line"><span class="keyword">if</span>(dep[fa[x][i]] &gt;= dep[y])x = fa[x][i];</span><br><span class="line"><span class="keyword">if</span>(x == y)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=t;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line"><span class="keyword">if</span>(fa[x][i] != fa[y][i])x = fa[x][i], y = fa[y][i];</span><br><span class="line"><span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m; nn = <span class="built_in">sqrt</span>(<span class="number">2</span>*n), t = <span class="built_in">log2</span>(n)+<span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)   cin&gt;&gt;a[i], b[i] = a[i];</span><br><span class="line"><span class="built_in">sort</span>(b+<span class="number">1</span>, b+<span class="number">1</span>+n);</span><br><span class="line"><span class="type">int</span> cnt = <span class="built_in">unique</span>(b+<span class="number">1</span>, b+<span class="number">1</span>+n) - b - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)   a[i] = <span class="built_in">lower_bound</span>(b+<span class="number">1</span>, b+<span class="number">1</span>+cnt, a[i]) - b;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i)cin&gt;&gt;x&gt;&gt;y, g[x].<span class="built_in">pb</span>(y), g[y].<span class="built_in">pb</span>(x);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line"><span class="keyword">if</span>(in[x[i]] &gt; in[y[i]])<span class="built_in">swap</span>(x[i], y[i]);</span><br><span class="line"><span class="keyword">if</span>(out[x[i]] &gt;= out[y[i]])range[i] = node&#123; in[x[i]], in[y[i]], i, x[i], y[i]&#125;;</span><br><span class="line"><span class="keyword">else</span>range[i] = node&#123; out[x[i]], in[y[i]], i, x[i], y[i]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(range+<span class="number">1</span>, range+<span class="number">1</span>+m);</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="keyword">while</span>(r&lt;range[i].r)<span class="built_in">add</span>(st[++r]);</span><br><span class="line"><span class="keyword">while</span>(l&gt;range[i].l)<span class="built_in">add</span>(st[--l]);</span><br><span class="line"><span class="keyword">while</span>(r&gt;range[i].r)<span class="built_in">add</span>(st[r--]);</span><br><span class="line"><span class="keyword">while</span>(l&lt;range[i].l)<span class="built_in">add</span>(st[l++]);</span><br><span class="line"><span class="type">int</span> lca = <span class="built_in">LCA</span>(range[i].x, range[i].y);</span><br><span class="line"><span class="keyword">if</span>(lca != range[i].x &amp;&amp; lca != range[i].y)ans[range[i].id] = sum + (col[a[lca]] == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span>ans[range[i].id] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P5268-SNOI2017-一个简单的询问"><a href="#P5268-SNOI2017-一个简单的询问" class="headerlink" title="P5268 [SNOI2017] 一个简单的询问"></a><a href="https://www.luogu.com.cn/problem/P5268">P5268 [SNOI2017] 一个简单的询问</a></h3><p>给定一个序列，定义</p><p>$$\operatorname{get}(l,r,x)&#x3D;\sum_{i&#x3D;l}^r[a_i&#x3D;x]$$</p><p>对于每个询问 $(l_1,r_1,l_2,r_2)$，求</p><p>$$\sum_{x&#x3D;0}^{\infty}\operatorname{get}(l_1,r_1,x)\times \operatorname{get}(l_2,r_2,x)$$</p><p>这个东西直接弄显然是不好的，因为它需要我们维护两个区间。但是，我们可以试着将这两个区间拆开来看：</p><p>令</p><p>$$g(t,x)&#x3D;\sum_{i&#x3D;1}^t[a_i&#x3D;x]$$</p><p>于是显然有</p><p>$$\operatorname{get}(l,r,x)&#x3D;g(r,x)-g(l-1,x)$$</p><p>于是原式可以化成：</p><p>$$\sum_{x&#x3D;0}^{\infty}\operatorname{get}(l_1,r_1,x)\times \operatorname{get}(l_2,r_2,x)&#x3D;\sum_{x&#x3D;0}^{\infty}(g(r_1,x)-g(l_1-1,x))\times(g(r_2,x)-g(l_2-1,x))$$</p><p>这样，每个询问可以拆成四个询问，然后每个询问就好做了。</p><p>但是和普通莫队不一样的是，这里左端点也是往右加入点往左删除点，但其实也不麻烦，很好理解。</p><h3 id="P3709-大爷的字符串题"><a href="#P3709-大爷的字符串题" class="headerlink" title="P3709 大爷的字符串题"></a><a href="https://www.luogu.com.cn/problem/P3709">P3709 大爷的字符串题</a></h3><p>给定一个字符串，对于</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;莫队&quot;&gt;&lt;a href=&quot;#莫队&quot; class=&quot;headerlink&quot; title=&quot; 莫队 &quot;&gt;&lt;/a&gt;&lt;center&gt; 莫队 &lt;/center&gt;&lt;/h1&gt;&lt;h4 id=&quot;——优雅的暴力&quot;&gt;&lt;a href=&quot;#——优雅的暴力&quot; class=&quot;headerlin</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>动态规划（背包）</title>
    <link href="http://example.com/2024/08/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://example.com/2024/08/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2024-08-11T13:46:21.000Z</published>
    <updated>2024-08-11T13:49:25.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title=" 动态规划 "></a><center> 动态规划 </center></h1><p>动态规划有两个要点，就是状态和转移。</p><ul><li><strong>状态</strong>，很重要的一个点是它能够清晰地描述一个子问题。也就是说我们能够根据我们记录下来的东西能够方便得让我们知道我们在解决什么，要求什么，并且能够通过之前的状态转移过来。在满足这些条件的情况下，我们就可以进一步考虑我们到底需不需要记录这么多状态，是不是可以少记录一些来降低复杂度。</li><li><strong>转移</strong>，就是状态与状态之间的关系。我们需要从一些已知的状态求出一个未知的状态，这个过程就叫转移。转移的快慢很大一部分取决于转移的技巧。例如通过寻找最优决策点的时候有斜率优化、单调队列优化或者四边形不等式优化。有时候，并不是所有的状态都可以通过已知的状态转移过来，很多时候状态是一种类似于方程的形式，这时候就可以使用高斯消元来解决问题，只是复杂度会上升为三次。</li></ul><h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><p>相信背包一定是大部分 $\text{OIer}$ 最早接触的一类动态规划问题，但我发现我到最近才对它进行系统的学习，实在是太弱了。它的核心问题是有限制条件的选择物品。而 <strong>物品</strong> 这个概念也可以被抽象化，一般地，一个或一些物品可以看成一个 <strong>价值</strong> 对于 <strong>重量</strong> 的函数 $v &#x3D; f(w)$。但，物品也可以是很特殊的，例如 $\text{01背包}$ 中物品就是一个价值为 $val$ 重量为 $weight$ 的东西。但它也可以表示成一般的形式，即：</p><p>$$v&#x3D;\begin{cases}val,&amp;w&#x3D;weight\0,&amp;\text{otherwise}\end{cases}$$</p><p>除了直接的形式以外，还有很多题目会隐晦的考察背包问题，这就需要我们将问题的本质抓出来。</p><h2 id="01-背包"><a href="#01-背包" class="headerlink" title="$01$ 背包"></a>$01$ 背包</h2><p>$01$ 背包其实是所有背包问题的本质。但我们先不讲它为什么是本质，我们先考虑怎么做这个问题。</p><h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>首先考虑状态设计。考虑到先选什么后选什么并不会影响最终的答案，因此我们只需设选择了前 $i$ 个即可。另外，显然目前背包的大小也会影响我们能够选什么。这样，我们就有了一个初步的状态设计：在背包大小为 $j$ 的时候选择第 $i$ 个物品的最大价值。</p><p>下面开始考虑转移，显然，我在一个状态 $i,j$ 有两种选择，一种是选这个物品，一种是不选，于是就有转移：</p><p>$$f_{i,j}&#x3D;\max{f_{i-1,j},f_{i-1,j-w}+v}$$</p><p>于是我们就得到了一个时间复杂度和空间复杂度都为 $O(nV)$ 的算法。</p><p>但是，我们注意到这里第 $i$ 层只与 $i-1$ 层有关，因此我们可以开滚动数组来滚掉一维。另外，我们发现后面的状态更新只与前面的有关，因此我们完全可以不要前一维而直接从后往前进行更新，这样就可以完成 $O(V)$ 的空间复杂度，转移方程为：</p><p>$$f_{i} &#x3D; \max{f_i, f_{i-w}+v}$$</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(V, w[i], -<span class="number">1</span>):</span><br><span class="line">f[i] = <span class="built_in">max</span>(f[i-w[i]]+v[i], f[i])</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>与 $01背包$ 不同的是，这里的物品不一定只取一次，而是可以无限制地拿取。这样的物品写成一般的形式就是：</p><p>$$v&#x3D;\begin{cases}k\times val,&amp;w&#x3D;k\times weight,k\in \mathbb{N}\0,&amp;\text{otherwise}\end{cases}$$</p><h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol"></a>Sol</h3><h4 id="O-nV-2-做法"><a href="#O-nV-2-做法" class="headerlink" title="$O(nV^2)$ 做法"></a>$O(nV^2)$ 做法</h4><p>显然，我们除了知道现在背包的容量、取到了哪个物品以外，还需要知道现在的物品到底取多少件，枚举出来之后就很容易得到转移：</p><p>$$f_{i,j}&#x3D;\max_{k&#x3D;0}^{\infty}{f_{i-1,j-k\times w}+k\times v}$$</p><p>这样，对于每一件物品，复杂度是 $O(V\times \frac{V}{w})$，因此总的时间复杂度就是 $O(V^2\sum\frac{1}{w})$，很容易被卡到 $O(nV^2)$。</p><p>但是我们考虑，这其实相当于把这个物品拆成很多物品然后做 $01背包$。也就是说，一般地把</p><p>$$v&#x3D;\begin{cases}k\times val,&amp;w&#x3D;k\times weight,k\in \mathbb{N}\0,&amp;\text{otherwise}\end{cases}$$</p><p>拆成：</p><p>$$v_i&#x3D;\begin{cases}i\times val,&amp;w&#x3D;i\times weight\0,&amp;\text{otherwise}\end{cases}$$</p><p><strong>伪代码</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,V):</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,V/w[i]):</span><br><span class="line">f[i][j]=<span class="built_in">max</span>(f[i-<span class="number">1</span>][j-k*w[i]]+k*v[i],f[i][j]);</span><br></pre></td></tr></table></figure><h4 id="O-nV-log-V-做法"><a href="#O-nV-log-V-做法" class="headerlink" title="$O(nV\log V)$ 做法"></a>$O(nV\log V)$ 做法</h4><p>上述做法其实就是选择一定数量的这个物品，那么这个数量一定可以用二进制表示，也就是说，我们把这个物品拆成 $\log V$ 个，每个表示买 $1$ 个、$2$ 个、$\dots$、$2^{\left\lfloor\log V\right\rfloor}$ 个物品，显然任意数量可以用这些物品表示出来，于是做 $01 背包$ 即可。</p><p>形式化的，我们把</p><p>$$v&#x3D;\begin{cases}k\times val,&amp;w&#x3D;k\times weight,k\in \mathbb{N}\0,&amp;\text{otherwise}\end{cases}$$</p><p>拆成：</p><p>$$v_i&#x3D;\begin{cases}2^i\times val,&amp;w&#x3D;2^i\times weight\0,&amp;\text{otherwise}\end{cases}$$</p><p>即可。</p><p><strong>伪代码</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, log(V)):</span><br><span class="line">v[++idx] = (<span class="number">1</span>&lt;&lt;t)*v[i], w[idx] = (<span class="number">1</span>&lt;&lt;t)*w[i]</span><br></pre></td></tr></table></figure><h4 id="O-nV-做法"><a href="#O-nV-做法" class="headerlink" title="$O(nV)$ 做法"></a>$O(nV)$ 做法</h4><p>更加快地，我们可以做到时间 $O(nV)$，空间 $O(V)$。</p><p>具体地，我们考虑，如果按照 $01背包$ 的做法，但是从前往后地考虑完全背包，显然，如果当前选这个物品更优，我们直接选择即可，然后更新当前的值。当继续更新后面的节点的时候，我们就可以直接继承当前的值，如果继续选择就可以表示选两个、三个以及更多的情形。</p><p>这就相当于，我们已经选择了这个物品并加入了贡献，然后继续考虑下一个物品，考虑的时候就正好继承了上一次选的状态。</p><p><strong>伪代码</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, V):</span><br><span class="line">f[j] = <span class="built_in">max</span>(f[j], f[j-w[i]]+v[i])</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>与完全背包又不一样，多重背包限制了每个物品最多拿多少次，而非可以无限拿，这问题又难了一些。</p><p>同样地，我们依旧可以形式化表示这些物品：</p><p>$$v&#x3D;\begin{cases}k\times val,&amp;w&#x3D;k\times weight,k\in[0,m]\cap\mathbb{Z}\0,&amp;\text{otherwise}\end{cases}$$</p><h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol"></a>Sol</h3><p>显然，和完全背包一样，我们可以枚举选择多少个该物品。这里不详细展开。</p><p>又显然，和完全背包一样，我们可以把选择的物品二进制表示出来。但注意这里二进制拆分不能够把那些大于 $m$ 的状态也表示出来，因此，我们只能取到 $2^{\left\lfloor\log m\right\rfloor-1}$，剩下的我们就再取一个 $m-2^{\left\lfloor\log m\right\rfloor}+1$ 即可。</p><p>这里，我们着重讲一下 $O(nV)$ 做法。</p><p>显然，根据完全背包的做法，我们发现一个状态 $j$ 可以从 $j-w$，$j-2w$，$\dots$，$j-kw$ 转移过来，而这些数有一个共同特点，就是关于 $w$ 同余。而我们也不难证明，所有的关于 $w$ 余数不同的值都不能在这一层相互转移，于是，我们就可以枚举余数转移。</p><p>具体地，关于每一个余数，我们发现一个点 $j$ 只能从 $j-w$ 一直到 $j-mw$ 中最大的转移过来，这显然符合单调队列优化的条件。因此，我们在转移的时候使用一个单调队列优化就可以 $O(nV)$ 通过这个问题。</p><p>但是，还有一个细节。就是每一次我们算的 $f_j$ 不能直接用到单调队列中，因为这些值已经加上了我们的贡献 $kv$，因此，加入单调队列的应该是 $f_j-kv$。</p><h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line"><span class="built_in">int</span> res = <span class="built_in">min</span>(m, V/w);</span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, w-<span class="number">1</span>):</span><br><span class="line">head = <span class="number">0</span>, tail = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> lim = (V-d)/w;</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, lim):</span><br><span class="line"><span class="keyword">while</span> head &lt;= tail <span class="keyword">and</span> f[j*w+d]-j*v &gt;= q[tail]:</span><br><span class="line">--tail;</span><br><span class="line">q[++tail] = f[j*w+d]-j*v, num[tail] = j;</span><br><span class="line"><span class="keyword">while</span> head &lt;= tail <span class="keyword">and</span> num[head]+res &lt; j:</span><br><span class="line">++head;</span><br><span class="line">f[j*w+d]=q[head]+j*v;</span><br></pre></td></tr></table></figure><h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><p>显然，上述的三种背包混合起来就都可以转化成多重背包问题。完全背包直接转化成数量只有 $\frac{V}{w}$ 即可。</p><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>在完成上述三种背包之后，我们对于背包问题又有了一个基本的了解。进一步拓展，我们发现，如果我们最终求出了动态规划的数组 $f_V$ 这是不是也可以看成一种一般意义上的物品。它表示为一个函数</p><p>$$v&#x3D;f_w$$</p><p>这样，我们就能够接着完成一些接下来的背包：</p><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><h3 id="Sol-3"><a href="#Sol-3" class="headerlink" title="Sol"></a>Sol</h3><p>与之前不同的是，现在的物品多了一些组别。而每个组内只能选择一个物品。</p><p>状态设计上，因为每个组只能选择一个，因此我们考虑 $f_{i,j}$ 表示前 $i$ 组容量为 $j$ 时的最大价值。状态确实很好地描述了一个子问题，但是我们仍需要考虑的是怎么保证每个组只选一个。</p><p>显然，我们仍然需要从大到小枚举容量 $V$，然后，按照一般的 $01背包$ 的思路，我们现在要考虑选择或者不选择。那么，按照分组背包的思路，我们是不是应该考虑选择哪个更合适呢？因此，我们不难得出状态转移方程：</p><p>$$f_j&#x3D;\max_{k\in group_i}{f_{j-w_k}+v_k}$$</p><h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(V, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line"><span class="keyword">for</span> k:group[i]:</span><br><span class="line">f[j] = <span class="built_in">max</span>(f[j], f[j-w[k]]+v[k]);</span><br></pre></td></tr></table></figure><p>结合我们上文所说的，其实这里的每个组可以被看成一个广义上的物品，我们假设组内有 $s$ 个物品，价值与重量分别为 $v_i$ 和 $w_i$，那么这个物品就可以被写成函数的一般形式：</p><p>$$v&#x3D;\begin{cases}v_i, &amp;w&#x3D;w_i,i\in[1,s]\cap \mathbb{Z}\0,&amp;\text{otherwise}\end{cases}$$</p><p>而这里就是这个一般性的物品在 $01背包$ 时的解法。</p><p>显然，这种情况下，如果是完全背包，就没有了组内的限制，显然直接把组拆开即可。</p><p>那么我们继续跟着这个思路，如果我们给每个组的背包限制一个容量，那么我们就可以根据一般物品的思路，现在每个组内求出每个组的函数 $v(w)$，然后把 $w$ 重量拆成特殊意义的物品，即每个物品的重量、价值可以表示成二元组 $(w,v(w))$。这样，就可以继续使用背包完成了。</p><p>高维背包我不想讲，无非就是 $DP$ 数组上多加几维罢辽。</p><h2 id="小节-1"><a href="#小节-1" class="headerlink" title="小节"></a>小节</h2><p>我们在探讨完一般的背包问题之后，会发现一个有意思的现象。对于刚开始给出的物品 $(w_i, v_i)$，我们可以写成一个函数：</p><p>$$f(w) &#x3D; \begin{cases}v_i, &amp;w&#x3D;w_i\0,&amp;\text{otherwise}\end{cases}$$</p><p>然后，我们通过动态规划之后，把它重新整合成了另一种一般的物品，即最终的动态规划数组 $f_w$。我们发现，在一般的条件下，我们只需要这一维数组就足以描述一个子问题。</p><h2 id="进阶：01背包-k-优解"><a href="#进阶：01背包-k-优解" class="headerlink" title="进阶：01背包 $k$ 优解"></a>进阶：01背包 $k$ 优解</h2><h3 id="Sol-4"><a href="#Sol-4" class="headerlink" title="Sol"></a>Sol</h3><p>现在，我们已经不满足于只知道最优解，我们想知道，如果我们有很多人，也就是说，在每个人选的物品不能完全相同的情况下，第 $k$ 个人的最优解是什么。</p><p>很显然，最开始的 $f_{j}$ 的状态已经不能满足我们对于新的题目的追求，但是，它仍然是必要的，只不过不充分。既然要求我们求出 $k$ 优解，那么我们不妨设 $f_{j,k}$ 表示背包容量为 $j$ 时的 $k$ 优解。</p><p>然后，我们来想想如何转移。对于现在枚举的物品 $i$ 和背包容量 $j$，那么这个背包的容量就应该由 $j-w_i$ 转移过来。而我们要求的是前 $k$ 优解，那么容量为 $j$ 时的 $k$ 优解一定不比 $j-w_i$ 层的劣。根据原来的 $01背包$，会产生 $f_{j,1},\dots,f_{j,k}$ 这些不同的背包价值以及更新上来的 $f_{j-w_i,1}+v_i,\dots,f_{j-w_{i},k}+v_i$ 总共 $2k$ 种价值。这些价值一定包含前 $k$ 优解，而我们又知道 $f_{j}$ 是单调不升的（因为最优解一定比次优解优，以此类推），因此使用类似于归并的方法可以使得转移一次复杂度变成 $O(k)$，因此总的复杂度就是时间 $O(knV)$，空间 $O(kn)$。</p><h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p>所以为什么前 $k$ 优解就一定包含在这 $2k$ 个状态中呢？这就像询问为什么朴素的 $01背包$ 的最优解一定在 $f_j$ 与 $f_{j-w_i}+v_i$ 之中一样。对于背包容量为 $j$ 的问题，在物品 $i$ 已经枚举确定的情况下，我们能且只能通过 $j-w_i$ 的背包容量转移过来，而在 $j-w_i$ 的背包容量的情况下，比 $k$ 优解更劣的解一定不会对当前产生贡献，因为 $f_{j-w_i,1}+v_i$ 到 $f_{j-w_i,k}+v_i$ 已经至少有 $k$ 个，而 $f_{j-w_i,k}\ge f_{j-w_i,k+1}$。同理我们可以知道继承上一层的 $j$ 容量状态最多也只到 $k$ 优。因此这 $2k$ 个状态就决定了现在的 $f_{j,1}$ 到 $f_{j,k}$。</p><h3 id="Code【P1858-多人背包】"><a href="#Code【P1858-多人背包】" class="headerlink" title="Code【P1858 多人背包】"></a><a href="https://www.luogu.com.cn/problem/P1858">Code【P1858 多人背包】</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], w[N], f[M][K], n, k, m, tmp[K];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;k&gt;&gt;m&gt;&gt;n;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=w[i];--j)&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cnt &lt;= k)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[j-w[i]][y] + v[i] &gt; f[j][x])tmp[++cnt] = f[j-w[i]][y++]+v[i];</span><br><span class="line"><span class="keyword">else</span>tmp[++cnt] = f[j][x++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=k;++x)f[j][x] = tmp[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)ans += f[m][i];</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot; 动态规划 &quot;&gt;&lt;/a&gt;&lt;center&gt; 动态规划 &lt;/center&gt;&lt;/h1&gt;&lt;p&gt;动态规划有两个要点，就是状态和转移。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;状</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>容斥</title>
    <link href="http://example.com/2024/08/11/%E5%AE%B9%E6%96%A5/"/>
    <id>http://example.com/2024/08/11/%E5%AE%B9%E6%96%A5/</id>
    <published>2024-08-11T13:46:21.000Z</published>
    <updated>2024-08-11T13:45:59.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title=" 容斥原理 "></a><center> 容斥原理 </center></h1><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>首先，我们来看集合只有两个的情况。如果有集合 $A,B$，求 $|A\cup B|$，那么我们可以先将两个集合里面的元素数量加起来，然后再减去两个集合都有的元素，也就是 $|A\cup B| &#x3D; |A|+|B|-|A\cap B|$。</p><p>然后，再看有三个的情况。对于集合 $A,B,C$，如果我们要求 $|A\cup B\cup C|$，那么显然就是三个集合内的元素个数加起来，再分别减去相交的，然后再加回来三个都相交的。即 $|A\cup B\cup C| &#x3D; (|A|+|B|+|C|) - (|A\cap B| + |B\cap C| + |C\cap A|) + |A\cap B\cap C|$。</p><p>于是，我们不妨猜测结论有 $n$ 个集合 $S_i(i\in [1,n])$，则：</p><p>$$<br>\left |\bigcup_{i&#x3D;1}^n S_i\right | &#x3D; \sum_{i&#x3D;1}^n(-1)^{i-1}\sum_{a_j\le a_{j-1}}\left |\bigcap_{j&#x3D;1}^i S_{a_i} \right |<br>$$</p><p>其中，$\displaystyle \sum_{a_j\le a_{j+1}} \left |\bigcap_{j&#x3D;1}^i S_{a_i} \right |$ 可以认为是在 $n$ 个集合选择 $i$ 个交起来的集合大小的和。而这一步最主要的目的便是将 $\bigcup$ 变成了一堆 $\bigcap$ 的和，当然我们需要加上容斥系数 $(-1)^{i-1}$。</p><blockquote><p><strong>证明</strong></p><p>首先，我们假设有全集 $U$，于是显然地：</p><p>$$<br>\displaystyle\left |\bigcup\limits_{i&#x3D;1}^n S_i \right|\Leftrightarrow \sum_{x\in U} \bigvee_{i&#x3D;1}^n\left[x\in S_i\right]<br>$$<br>也就是说，所有出现在全集中的，且在 $S_1,\dots,S_n$ 中出现至少一次的会贡献一。</p><p>于是，我们设元素 $x\in U$ 在 $S_{b_1},S_{b_2},\dots,S_{b_m}$ 中出现过，那么在式子 $\displaystyle \sum_{i&#x3D;1}^n (-1)^{i-1}\sum_{a_j\le a_{j+1}}\left | \bigcap_{j&#x3D;1}^m S_{a_j} \right |$ 中，它显然在序列 ${a_i}\sube {b_m}$ 时才会产生贡献，其中这贡献是 $(-1)^{i-1}$。于是，我们对于 $i\in [1,m]$ 分别考虑。对于任意一个 $i$，我们显然需要先从 $b_m$ 中选择 $i$ 个来生成这个 ${a_i}$，然后这些都会贡献 $(-1)^{i-1}$。那么，这元素就一共会产生<br>$$<br>\sum_{i&#x3D;1}^m\binom{m}{i}(-1)^{i-1}<br>$$<br>的贡献。而这个式子不难证明等于 $1$。于是我们就证明了它的正确性。另外，这式子也可以用数学归纳法证明，这里不讲了。</p></blockquote><p>上面我们探讨了如何将 $\bigcup$ 变成许多的 $\bigcap$，但是，如果我们希望求 $\bigcup$，而问题是求 $\bigcap$ 怎么办呢？</p><p>这其实也非常简单，我们可以借助另一个式子：<br>$$<br>\left |\bigcap_{i&#x3D;1}^n S_i\right | &#x3D; \left | U \right | - \left | \bigcup_{i&#x3D;1}^n \overline{S_{a_i}} \right |<br>$$<br>其中 $\overline S$ 代表 $S$ 在 $U$ 意义下的补集。即 $\overline S &#x3D; \complement _{U} S$。这个式子表明，交集的大小等于全集减去它们补集的并的大小。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>我们刚刚探讨了容斥的基本式子以及它们的推导，但是我们还并未探讨如何应用这些式子。</p><h2 id="不定方程模型"><a href="#不定方程模型" class="headerlink" title="不定方程模型"></a>不定方程模型</h2><p>而为了方便地继续探讨，我们在这里先引入一个例子：</p><blockquote><p><strong>例题</strong></p><p>求不定方程 $\displaystyle \sum_{i&#x3D;1}^n x_i &#x3D; m$ 的非负整数解的个数。其中给出 $n$ 个限制，每个限制形如 $x_i\le b_i$。</p></blockquote><h3 id="容斥模型"><a href="#容斥模型" class="headerlink" title="容斥模型"></a>容斥模型</h3><p>在做题目的时候，我们需要注意找准以下三个要素：</p><ul><li>全集，即 $U$，这里我们设所有的 $n$ 阶满足 $\sum\limits_{i&#x3D;1}^n x_i &#x3D; m$ 的行向量组成的集合为 $U$，即 $U&#x3D;{(x_1,x_2,\dots,x_n)\mid x_i\in\mathbb{N},\sum x_i &#x3D; m,i\in[1,n]}$。</li><li>元素。这里虽然 $U$ 中的元素为行向量，但是，因为限制条件为 $x_i\le b_i$，所以这里元素选择 $x_i$。</li><li>属性。这里的属性是定义我们 $S_i$ 的关键。我们这里的属性就是题目中给出的性质 $x_i\le b_i$，而集合 $S_i$ 就表示为满足属性 $i$ 的解的数量，当然了，它还得满足条件 $\sum x_i &#x3D; m$。即 $\left |S_i\right | &#x3D; \sum\limits_{X\in U} [x_i\le b_i\wedge \sum x_i &#x3D; m]$。</li></ul><p>因为我们要满足所有的条件，所以我们要求的就是这些集合的交集，即 $\displaystyle\left | \bigcap_{i&#x3D;1}^n S_i \right |$。</p><p>然后我们要找找自己会做什么。首先大家肯定会没有限制的时候，即 $\left | U \right | $。而这个问题就是典型的插板问题。这不定方程 $\sum x_i &#x3D; m$ 就等价于给 $m$ 个苹果和互不相同的盘子，每个盘子可以为空，问有多少放的方法。直接插板即可，答案就是 $\displaystyle\binom{n+m-1}{n-1}$。</p><p>再然后，我们发现我们还会如果令 $x_i&gt;b_i$ 的做法。显然，如果我们要让 $x_i&gt;b_i$ 那么就先给 $x_i$ 分配 $b_i+1$ 个然后就可以随便分了。于是满足第 $a_1,a_2,\dots,a_k$ 个条件（这里的条件是限制的补集）的答案，这就相当于让我们解不定方程 $\sum x_i &#x3D; m-\sum (b_{a_i}+1)$。答案即为 $\displaystyle\binom{m-\sum({b_{a_i}}+1)+n-1}{n-1}$。因为我们这是同时满足了一些限制的补集，也就是我们知道了 <strong>一些限制的补集的交的快速做法</strong>，也就是会了 $\displaystyle\bigcap \overline{S_{a_i}}$，而我们要求的是 $\displaystyle\bigcap_{i&#x3D;1}^nS_i$，于是我们按照刚刚学习的那两个公式展开一下：<br>$$<br>\begin{aligned}<br>\left |\bigcap_{i&#x3D;1}^n S_i \right |<br>&amp;&#x3D; \left | U \right | - \left | \bigcup_{i&#x3D;1}^n \overline{S_i} \right |\<br>&amp;&#x3D; \left | U \right | - \sum_{k&#x3D;1}^n (-1)^{i-1}\sum_{a_i\le a_{i+1}}\left | \bigcap_{i&#x3D;1}^k \overline{S_{a_i}} \right |<br>\end{aligned}<br>$$<br>然后你就完全理解了。但是因为这里 $x_i$ 两两不同，所以需要 $2^n$ 求。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="HAOI2008-硬币购物"><a href="#HAOI2008-硬币购物" class="headerlink" title="HAOI2008 硬币购物"></a><a href="https://www.luogu.com.cn/problem/P1450">HAOI2008 硬币购物</a></h4><p>就和这个题完全一样，只是 $x_i$ 前加了系数 $c_i$，并无本质区别。</p><h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> f[N], d[<span class="number">5</span>], c[<span class="number">5</span>], n, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;c[<span class="number">1</span>]&gt;&gt;c[<span class="number">2</span>]&gt;&gt;c[<span class="number">3</span>]&gt;&gt;c[<span class="number">4</span>]&gt;&gt;n;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=c[i];j&lt;=N<span class="number">-10</span>;++j)</span><br><span class="line">f[j] += f[j-c[i]];</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">cin&gt;&gt;d[<span class="number">1</span>]&gt;&gt;d[<span class="number">2</span>]&gt;&gt;d[<span class="number">3</span>]&gt;&gt;d[<span class="number">4</span>]&gt;&gt;s;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">16</span>;++i)&#123;</span><br><span class="line"><span class="type">int</span> m = s, k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;++j)</span><br><span class="line"><span class="keyword">if</span>((i&gt;&gt;j<span class="number">-1</span>)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">m -= (d[j]+<span class="number">1</span>)*c[j];</span><br><span class="line">++k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(m&gt;=<span class="number">0</span>)ans += (k%<span class="number">2</span>*<span class="number">2</span><span class="number">-1</span>) * f[m];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[s] - ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>我们现在有两个公式：</p><ul><li>$\left |\bigcup\limits_{i&#x3D;1}^n S_i\right | &#x3D; \sum\limits_{k&#x3D;1}^n(-1)^{k-1}\sum\limits_{a_i\le a_{i+1}}\left | \bigcap\limits_{i&#x3D;1}^k S_{a_i} \right |$，它可以把 <strong>至少满足一个</strong> 的条件转化为 <strong>必须都满足</strong> 的条件。</li><li>$\left | \bigcap\limits_{i&#x3D;1}^n S_i \right | &#x3D; \left | U \right | - \left | \bigcup\limits_{i&#x3D;1}^n \overline{S_i} \right |$，它可以把 <strong>必须都满足</strong> 的条件转化为 <strong>至少满足一个</strong>。而这里条件要取反。</li></ul><h1 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h1><h2 id="JSOI2015-染色问题"><a href="#JSOI2015-染色问题" class="headerlink" title="JSOI2015 染色问题"></a><a href="https://www.luogu.com.cn/problem/P6076">JSOI2015 染色问题</a></h2><h3 id="Des"><a href="#Des" class="headerlink" title="Des"></a>Des</h3><p>给定一个 $n\times m$ 的矩阵，每个格子上可以涂 $k$ 种颜色，要求：</p><ul><li>每个颜色都必须用上。</li><li>每一行、每一列都至少要有一个格子涂了颜色。</li></ul><p>求涂的方案数。模数。</p><h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>首先，这里很显然有两个限制。我们先考虑第一个。</p><p>因为有限制 <strong>每个颜色必须使用</strong>，我们就设 $S_i$ 表示使用了 $i$ 颜色的方案数。于是我们要求的就是 $\left|\bigcap\limits_{i&#x3D;1}^n S_i\right|$。然后，我们发现，我们会求 <strong>至少有 $k$ 个颜色不用</strong> 的情况下的颜色数量。因为至少有 $k$ 个颜色不用，换句话说，我们 <strong>钦定</strong> $k$ 个颜色不能用，剩下的用不用都可以，这样的方案数我们设有 $f_{c-k}$ 个（$c$ 为颜色数量），也即 $f_i$ 表示最多使用 $i$ 个颜色且满足条件二的方案数。也即 $\left | \bigcap\limits_{i&#x3D;1}^k \overline{S_{a_i}} \right | &#x3D; f_{c-k}$。于是我们就对于答案进行了最初的转化：<br>$$<br>\begin{aligned}<br>\left | \bigcap_{i&#x3D;1}^c S_i \right |<br>&amp;&#x3D; \left | U \right | - \left | \bigcup_{i&#x3D;1}^c\overline{S_i} \right |\<br>&amp;&#x3D; \left | U \right | - \sum_{k&#x3D;1}^c(-1)^{k-1}\sum_{a_i\le a_{i+1}}\left | \bigcap_{i&#x3D;1}^k \overline{S_{a_i}} \right |\<br>&amp;&#x3D; \left | U \right | - \sum_{k&#x3D;1}^c(-1)^{k-1}\binom{c}{k}f_{c-k}<br>\end{aligned}<br>$$<br>其中组合数 $\binom{c}{k}$ 是因为 $c$ 中颜色是一样的，故我们随便选择一组 $k$ 个即可。</p><p>于是问题就变成了求 $f_i$。这里我们再使用一次容斥，$S_i$ 表示 $i$ 列并没有空余的情况，于是我们要求的就是 $\left | \bigcap\limits_{i&#x3D;1}^m S_i \right |$。然后我们考虑什么好做。发现如果我们 <strong>钦定</strong> $k$ 列没有不涂颜色，我们可以轻松算出答案是 $((i+1)^{m-k}-1)^n$。其中 $i+1$ 代表了我们现在使用的颜色数量（加上空白的），而 $m-k$ 指的是 $m-k$ 列随便填，又因为每一行不能为空，所以要减去一种全空的情况，然后 $n$ 行互不相同，就在外面套一个 $n$ 次幂。而 $k$ 列为空代表的集合是 $\left | \bigcap\limits_{i&#x3D;1}^k \overline{S_{a_i}} \right |$，然后再按照套路将要求的 $\left | \bigcap\limits_{i&#x3D;1}^m S_i \right |$ 展开一下，就能够得到：<br>$$<br>f_i&#x3D;((i+1)^m-1)^n - \sum_{k&#x3D;1}^m (-1)^{k-1}\binom{m}{k}((i+1)^{m-k}-1)^n<br>$$<br>最后回带即可。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> f[N], C[N][N];</span><br><span class="line"><span class="type">int</span> n, m, c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; m; m&gt;&gt;=<span class="number">1</span>, x=x*x%MOD)<span class="keyword">if</span>(m &amp; <span class="number">1</span>)ans = ans*x%MOD;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-10</span>;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;++j)</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">0</span>)C[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>C[i][j] = (C[i<span class="number">-1</span>][j] + C[i<span class="number">-1</span>][j<span class="number">-1</span>])%MOD;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=c;++i)&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;++k)</span><br><span class="line">sum = (sum + ((k&amp;<span class="number">1</span>)*<span class="number">2</span><span class="number">-1</span>) * C[m][k] * <span class="built_in">ksm</span>((<span class="built_in">ksm</span>(i+<span class="number">1</span>, m-k)%MOD<span class="number">-1</span>+MOD)%MOD, n)%MOD + MOD) %MOD;</span><br><span class="line">f[i] = (<span class="built_in">ksm</span>((<span class="built_in">ksm</span>(i+<span class="number">1</span>, m)<span class="number">-1</span>+MOD)%MOD, n)-sum+MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = f[c], sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=c;++i)</span><br><span class="line">sum = (sum + ((i&amp;<span class="number">1</span>)*<span class="number">2</span><span class="number">-1</span>) * C[c][i] * f[c-i] % MOD + MOD) %MOD;</span><br><span class="line">cout&lt;&lt;(ans-sum+MOD)%MOD&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;容斥原理&quot;&gt;&lt;a href=&quot;#容斥原理&quot; class=&quot;headerlink&quot; title=&quot; 容斥原理 &quot;&gt;&lt;/a&gt;&lt;center&gt; 容斥原理 &lt;/center&gt;&lt;/h1&gt;&lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>杂题</title>
    <link href="http://example.com/2024/08/11/%E6%9D%82%E9%A2%98%E5%A5%BD%E9%A2%98/"/>
    <id>http://example.com/2024/08/11/%E6%9D%82%E9%A2%98%E5%A5%BD%E9%A2%98/</id>
    <published>2024-08-11T13:46:21.000Z</published>
    <updated>2024-08-11T13:49:48.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h1><h2 id="P5021-NOIP2018-提高组-赛道修建"><a href="#P5021-NOIP2018-提高组-赛道修建" class="headerlink" title="P5021 [NOIP2018 提高组] 赛道修建"></a><a href="https://www.luogu.com.cn/problem/P5021">P5021 [NOIP2018 提高组] 赛道修建</a></h2><h3 id="Des"><a href="#Des" class="headerlink" title="Des"></a>Des</h3><p>给定一棵树，有边权，要求找一些简单路径，使得路径上的边无交，并且最大化最小路径长度。</p><h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>看到题面直接想二分，显然答案也满足单调性。这里二分答案，问题转换为判断某个权值可不可行。</p><p>考虑如何判断。首先考虑菊花的情况，显然，任意两条边可以连成一条路径，当然，一条边也可以独自成为一条路径。</p><p>我们设现在要判断的值是 $lim$，于是把所有边权大于 $lim$ 的拿出来单独做一条路径，然后剩下的 <strong>从小的开始</strong> 看能不能找到一条边使得能凑出一条大于 $lim$ 的路径。这个过程可以二分完成。复杂度 $n\log v\log n$。</p><p>然后考虑不是菊花图的情况。因为路径不重，因此每个儿子只会传递上来一条路径，这就又变成了菊花图的情况。因此，我们首先找到儿子传递上来的边权大于等于 $lim$ 的所有边加上贡献，然后删除。对于小于 $lim$ 的情况，也是 <strong>从小的开始</strong> 尝试配对。最后，如果还有剩余没有配对的，就直接选一个最大的当做传递到父亲的边即可。复杂度 $O(n\log n\log v)$。</p><h4 id="这里有一些坑"><a href="#这里有一些坑" class="headerlink" title="这里有一些坑"></a>这里有一些坑</h4><ul><li>因为从小的开始，因此 **不能够匹配失败就 <code>break</code>**。</li><li>但我们同样 <strong>不能从大的开始</strong>，因为很有可能大的还要传递上去成为当前节点传递的路径。</li></ul><h4 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h4><p>首先，这里只需要证明在当前节点组成路径一定不比传递上去更劣。</p><p>考虑到传递上去也最多和其它路径构成一条路径或者自己成为一条路径，还可能会浪费掉别的一条路径，而在这里没有与之配对的边就完全没用了，因此我们不如把当前可以配对的全部配对，再把剩下的最大的传递上去，这绝对不劣。</p><h2 id="P6655-YsOI2020-制高"><a href="#P6655-YsOI2020-制高" class="headerlink" title="P6655 [YsOI2020] 制高"></a><a href="https://www.luogu.com.cn/problem/P6655">P6655 [YsOI2020] 制高</a></h2><h3 id="Des-1"><a href="#Des-1" class="headerlink" title="Des"></a>Des</h3><p>有一棵 $1$ 为根的有根树，点有点权，但我们并不清楚树的结构关系，我们只知道 $i$ 的父亲在 $l_i$ 到 $r_i$ 之间。如果 $val_x \ge val_{fa_x}$ 或 $x&#x3D;1$ 则该点会产生贡献。求所有情况的贡献和。</p><h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol"></a>Sol</h3><p>首先，考虑到一个节点会贡献多少次取决于它的父亲的贡献概率。也就是说，如果我们已知父亲的贡献概率 $f_i$，那么显然有：</p><p>$$f_i &#x3D; \frac{1}{r_i-l_i+1}\sum_{j&#x3D;l_i}^{r_i}[h_i\ge h_j]f_j$$</p><p>于是我们就是用期望 $DP$，状态同上，然后转移的时候使用主席树，最后答案就是：</p><p>$$(\sum_{i&#x3D;1}^nf_i)\prod_{i&#x3D;1}^n(r_i-l_i+1)$$</p><p>或者，我们想想还可不可以用另一种方式求出 $f_i$。</p><p>注意到，如果我们把节点按照点权排序，那么因为大的一定不会贡献给小的，这样我们在处理最小的点权的时候就可以直接设为 $0$，然后每一次在 $l_i$ 加上 $r_i$，然后统计就可以了。这样可以做到常熟更小的 $O(n\log n)$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;杂题&quot;&gt;&lt;a href=&quot;#杂题&quot; class=&quot;headerlink&quot; title=&quot;杂题&quot;&gt;&lt;/a&gt;杂题&lt;/h1&gt;&lt;h2 id=&quot;P5021-NOIP2018-提高组-赛道修建&quot;&gt;&lt;a href=&quot;#P5021-NOIP2018-提高组-赛道修建&quot; class</summary>
      
    
    
    
    
    <category term="题解笔记" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>二项式反演</title>
    <link href="http://example.com/2024/08/11/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/"/>
    <id>http://example.com/2024/08/11/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/</id>
    <published>2024-08-11T13:45:21.000Z</published>
    <updated>2024-08-11T13:45:29.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二项式反演"><a href="#二项式反演" class="headerlink" title=" 二项式反演"></a><center> 二项式反演</center></h1><h2 id="前置：组合数学基础"><a href="#前置：组合数学基础" class="headerlink" title="前置：组合数学基础"></a>前置：组合数学基础</h2><h3 id="插板法"><a href="#插板法" class="headerlink" title="插板法"></a>插板法</h3><p>还是由一个例题引入。解不定方程 $\sum x_i &#x3D; m$ 中正整数解的个数。 </p><p>这就可以看成我们一共有 $m$ 个小球，然后分成 $n$ 组，其中每组不能为空。那这就相当于在 $m$ 个小球组成的 $m-1$ 个空隙中随意插板，这样就一共有 $\binom{m-1}{n-1}$ 种情况。</p><p>现在，如果 <strong>正整数</strong> 变为 <strong>非负整数</strong>，又该怎么办呢？</p><p>我们发现，如果提前先给每个人分到 $1$ 个小球，问题就又变成了正常的正整数问题了。这样小球会多出来 $n$ 个，于是这问题就是 $n+m$ 个小球中插入 $n$ 块板，答案就是 $\binom{n+m-1}{n-1}$。</p><p>现在，我们又要求所有的 $x_i$ 有一个限制条件是 $x_i\ge b_i$，那么如何做呢？</p><p>显然，我们先给每个人分 $b_i$ 个球，然后就变成了第二个问题，于是答案就是 $\displaystyle\binom{m-\sum b_i+n-1}{n-1}$。</p><h3 id="多重集组合数"><a href="#多重集组合数" class="headerlink" title="多重集组合数"></a>多重集组合数</h3><p>如果有集合 $S &#x3D; {n_1\times a_1, n_2\times a_2,\dots,n_m\times a_m}$，其中 $a_i$ 前面的系数 $n_i$ 表示 $a_i$ 的个数，这样，我们在设 $n &#x3D; \sum n_i$</p><p>，那么这些数的全排列的数量就是 $\displaystyle\frac{n!}{\prod n_i!}$，这是因为所有的排列里面同一个元素是不区分的。而这 $\displaystyle\frac{n!}{\prod n_i!}$ 就是多重集的排列数，也被称为 <strong>多重组合数</strong>。记为：<br>$$<br>\binom{n}{n_1,n_2,\dots,n_k} &#x3D; \frac{n!}{\prod n_i !}<br>$$<br>它具体的内容拓展可以看 <strong>容斥原理</strong> 一节中有限制条件 $x_i\le b_i$ 的不定方程 $\sum x_i &#x3D; m$。</p><h3 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h3><p>这就不得不提到我们小学二年级就学过的二项式定理了。它被写作：<br>$$<br>(x+y)^n &#x3D; \sum_{i&#x3D;0}^n \binom{n}{i} x^iy^{n-i}<br>$$<br>同样，对于元数的拓展，我们可以使用多重集合数或者 <strong>杨辉高维体</strong> 的方法求得系数：<br>$$<br>(\sum x_i)^n &#x3D; \sum_{\sum n_i &#x3D; n} \binom{n}{n_1,n_2,\dots,n_k}\prod x_i^{n^i}<br>$$<br>其中，要求 $\forall i\in[1,k]\cap \mathbb{Z}$，有 $n_i \ge 0 \and n_i\in \mathbb{Z}$。</p><p>这里，多重组合数也有类似于一般组合数的性质，例如：<br>$$<br>\sum_{<br>\begin{matrix}<br>\sum n_i &#x3D; n\<br>n_i\in [0,+\infty]\cap \mathbb{Z}<br>\end{matrix}<br>}<br>\binom{n}{n_1,n_2,\dots,n_k} &#x3D; k^n<br>$$</p><h3 id="组合数的性质"><a href="#组合数的性质" class="headerlink" title="组合数的性质"></a>组合数的性质</h3><p>这里我们 <del>根据 $\text{OI-wiki}$ 给出的式子</del>，讲一讲组合数的一些进阶定理。</p><h4 id="组合数的对称性"><a href="#组合数的对称性" class="headerlink" title="组合数的对称性"></a>组合数的对称性</h4><p>$$<br>\binom{n}{m} &#x3D; \binom{n}{n-m}<br>$$</p><p>这是因为在 $n$ 中选择 $m$ 个显然等价于选择 $m$ 个剩下 $n-m$ 个。</p><h4 id="递推式1"><a href="#递推式1" class="headerlink" title="递推式1"></a>递推式1</h4><p>$$<br>\binom{n}{m} &#x3D; \frac{n}{m}\binom{n-1}{m-1}<br>$$</p><blockquote><p><strong>证明</strong></p><p>由定义：<br>$$<br>\begin{aligned}<br>\binom{n}{m} &amp;&#x3D; \frac{n!}{m!(n-m)!}\&amp; &#x3D; \frac{n}{m}\times \frac{(n-1)!}{(m-1)![(n-1)-(m-1)]!}\&amp;&#x3D;\frac{n}{m}\binom{n-1}{m-1}<br>\end{aligned}<br>$$</p></blockquote><h4 id="递推式2"><a href="#递推式2" class="headerlink" title="递推式2"></a>递推式2</h4><p>$$<br>\binom{n}{m} &#x3D; \binom{n-1}{m} +\binom{n-1}{m-1}<br>$$</p><blockquote><p><strong>证明</strong></p><p>根据组合数的意义，相当于 $n$ 个数里面选择 $m$ 个，我枚举最后一个 选&#x2F;不选，如果选，那么就在剩下的 $n-1$ 个里面选择 $m-1$ 个，否则在 $n-1$ 个里面选择 $m$ 个。</p></blockquote><h4 id="判零定理"><a href="#判零定理" class="headerlink" title="判零定理"></a>判零定理</h4><p>$$<br>\sum_{i&#x3D;1}^n(-1)^i\binom{n}{i} &#x3D; [n&#x3D;0]<br>$$</p><p>其中 $[n&#x3D;0]$ 代表 $f(n) &#x3D; \begin{cases} 1, &amp;n&#x3D;0\0, &amp;n\not &#x3D; 0 \end{cases}$。</p><blockquote><p><strong>证明</strong><br>$$<br>\begin{aligned}<br>\sum_{i&#x3D;1}^n(-1)^i\binom{n}{i} &amp;&#x3D; \sum_{i&#x3D;1}^n\binom{n}{i}(-1)^i1^{n-i}<br>\ &amp;&#x3D;(-1+1)^n\&amp;&#x3D;0^n\&amp;&#x3D;[n&#x3D;0]<br>\end{aligned}<br>$$</p></blockquote><h4 id="拆组合数"><a href="#拆组合数" class="headerlink" title="拆组合数"></a>拆组合数</h4><p>$$<br>\sum_{i&#x3D;0}^m\binom{n}{i}\binom{m}{i}&#x3D;\binom{n+m}{m}<br>$$</p><blockquote><p><strong>证明</strong><br>$$<br>\sum_{i&#x3D;0}^m\binom{n}{i}\binom{m}{i}&#x3D;\sum_{i&#x3D;0}^m\binom{n}{i}\binom{m}{m-i}<br>$$<br>而这个式子等价于在 $n+m$ 个数中枚举前 $n$ 个中要选择几个，然后给最后的答案贡献上前 $n$ 个选 $i$ 个的情况和后 $m$ 个选择 $m-i$ 个的情况，于是就等价于 $n+m$ 中选择 $m$ 个。</p></blockquote><h4 id="推论1"><a href="#推论1" class="headerlink" title="推论1"></a>推论1</h4><p>$$<br>\sum_{i&#x3D;0}^n\binom{n}{i}^2 &#x3D; \binom{2n}{n}<br>$$</p><p>由 <strong>拆组合数</strong>，该式显然成立。</p><h4 id="带权组合数"><a href="#带权组合数" class="headerlink" title="带权组合数"></a>带权组合数</h4><p>$$<br>\sum_{i&#x3D;0}^n i\binom{n}{i} &#x3D; n\times 2^{n-1}<br>$$</p><blockquote><p><strong>证明</strong></p><p>记：<br>$$<br>S &#x3D; \sum_{i&#x3D;0}^ni\binom{n}{i}<br>$$<br>于是：<br>$$<br>\begin{aligned}<br>2S &amp;&#x3D; \sum_{i&#x3D;0}^ni\binom{n}{i} + \sum_{i&#x3D;0}^ni\binom{n}{i}\<br>   &amp;&#x3D; \sum_{i&#x3D;0}^ni\binom{n}{i} + \sum_{i&#x3D;0}^ni\binom{n}{n-i}\<br>   &amp;&#x3D; \sum_{i&#x3D;0}^ni\binom{n}{i} +\sum_{i&#x3D;0}^n(n-i)\binom{n}{i}\<br>   &amp;&#x3D; \sum_{i&#x3D;0}^nn\binom{n}{i} &#x3D; n\times 2^n<br>\end{aligned}<br>$$<br>因此有 $S &#x3D; n\times 2^{n-1}$。</p></blockquote><h4 id="推论2"><a href="#推论2" class="headerlink" title="推论2"></a>推论2</h4><p>$$<br>\sum_{i&#x3D;0}^ni^2\binom{n}{i} &#x3D; n(n+1)2^{n-2}<br>$$</p><h4 id="约分公式"><a href="#约分公式" class="headerlink" title="约分公式"></a>约分公式</h4><p>$$<br>\binom{n}{k}\binom{k}{m} &#x3D; \binom{n}{m}\binom{n-m}{k-m}<br>$$</p><blockquote><p><strong>证明</strong></p><p>由定义：<br>$$<br>\begin{aligned}<br>\binom{n}{k}\binom{k}{m} &amp;&#x3D; \frac{n!}{k!(n-k)!}\times \frac{k!}{m!(k-m)!}\<br>&amp;&#x3D;\frac{n!(n-m)!}{(n-k)!(k-m)!m!(n-m)!}\<br>&amp;&#x3D;\frac{n!}{m!(n-m)!}\times \frac{(n-m)!}{(k-m)![(n-m)-(k-m)]!}\<br>&amp;&#x3D;\binom{n}{m}\binom{n-m}{k-m}<br>\end{aligned}<br>$$</p></blockquote><h2 id="正文：二项式反演"><a href="#正文：二项式反演" class="headerlink" title="正文：二项式反演"></a>正文：二项式反演</h2><p>如果有函数 $f(n),g(n)$，满足关系：<br>$$<br>g(n) &#x3D; \sum_{i&#x3D;0}^n \binom{n}{i} f_i<br>$$<br>则一定有相反的关系：<br>$$<br>f(n) &#x3D; \sum_{i&#x3D;0}^n\binom{n}{i}(-1)^{n-i}g_i<br>$$</p><blockquote><p><strong>证明</strong></p><p>不妨将 $g_n$ 的定义回带到反演公式中：<br>$$<br>\begin{aligned}<br>f(n) &amp;&#x3D; \sum_{i&#x3D;0}^n\binom{n}{i}(-1)^{n-i}g_i\<br>&amp;&#x3D; \sum_{i&#x3D;0}^n\binom{n}{i}(-1)^{n-i}\sum_{j&#x3D;0}^i\binom{i}{j}f_j<br>\end{aligned}<br>$$<br>这时候我们改变枚举顺序：<br>$$<br>\begin{aligned}<br>f_n &amp;&#x3D; \sum_{i&#x3D;0}^n\binom{n}{i}(-1)^{n-i}\sum_{j&#x3D;0}^i\binom{i}{j}f_j<br>\&amp;&#x3D; \sum_{i&#x3D;0}^n\sum_{j&#x3D;0}^i\binom{n}{i}\binom{i}{j}(-1)^{n-i}f_j\<br>&amp;&#x3D;\sum_{j&#x3D;0}^nf_j\sum_{i&#x3D;j}^n\binom{n}{i}\binom{i}{j}(-1)^{n-i}<br>\end{aligned}<br>$$<br>这个时候我们想起来刚刚学习的 <strong>约分公式</strong>：<br>$$<br>\begin{aligned}<br>f_n &amp;&#x3D; \sum_{j&#x3D;0}^nf_j\sum_{i&#x3D;j}^n\binom{n}{i}\binom{i}{j}(-1)^{n-i}\<br>&amp;&#x3D; \sum_{j&#x3D;0}^nf_j\sum_{i&#x3D;j}^n\binom{n}{j}\binom{n-j}{i-j}(-1)^{n-i}\<br>&amp;&#x3D; \sum_{j&#x3D;0}^nf_j\binom{n}{j}\sum_{i&#x3D;j}^n \binom{n-j}{i-j}(-1)^{n-i}<br>\end{aligned}<br>$$<br>我们记 $k&#x3D;i-j,m &#x3D; n-j$，然后枚举 $k$，得到：<br>$$<br>\begin{aligned}<br>f_n &amp;&#x3D; \sum_{j&#x3D;0}^nf_j\binom{n}{j}\sum_{i&#x3D;j}^n \binom{m}{i-j}(-1)^{n-i}\<br>&amp;&#x3D; \sum_{j&#x3D;0}^nf_j\binom{n}{j}\sum_{k&#x3D;0}^{n-j}\binom{m}{k}(-1)^{m-k}\<br>&amp;&#x3D; \sum_{j&#x3D;0}^n f_j\binom{n}{j} [n &#x3D; j]\<br>&amp;&#x3D; f_n<br>\end{aligned}<br>$$<br>证毕。</p></blockquote><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>另外，类似于莫比乌斯反演，它也有另一种表达形式：</p><p>如果有：<br>$$<br>g(n) &#x3D; \sum_{i&#x3D;n}^x\binom{i}{n}f_i<br>$$<br>则相反的，有：<br>$$<br>f_n &#x3D; \sum_{i&#x3D;n}^x\binom{i}{n}(-1)^{i-n}g_i<br>$$</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P6478-NOI-Online-2-提高组-游戏-P6478-NOI-Online-2-提高组-游戏-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#P6478-NOI-Online-2-提高组-游戏-P6478-NOI-Online-2-提高组-游戏-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="[P6478 [NOI Online #2 提高组] 游戏]([P6478 NOI Online #2 提高组] 游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn))"></a>[P6478 [NOI Online #2 提高组] 游戏]([P6478 <a href="https://www.luogu.com.cn/problem/P6478">NOI Online #2 提高组] 游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>)</h3><h4 id="Des"><a href="#Des" class="headerlink" title="Des"></a>Des</h4><p>给定一棵共有 $n&#x3D;2m$ 个节点的树。树上的每个节点有一个颜色，一共有两种颜色，每种颜色共 $m$ 个节点。共进行 $m$ 次操作，每次操作会从这棵树上选择两个没有被选过的异色点对。现在问对于 $\forall k\in[0,m]\cap \mathbb{Z}$，求在随机选点的情况下，$m$ 次选择有 $k$ 次选择的点对不为 祖先-儿子 对的情况数量。模数。</p><h4 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h4><p>题目的要求是求 <strong>恰好 $k$ 次不为 祖先-儿子 点对的情况数</strong>，我们设这为 $f_k$，而我们比较好求的是 <strong>钦定有 $k$ 次操作不为 祖先-儿子 关系的点对的情况数</strong>，设为 $g_k$。</p><blockquote><p><strong>Warning</strong></p><p>这里的 <strong>钦定</strong> 可以理解为 <strong>至少</strong> 有 $k$ 对，剩下的是不是我们不管。</p></blockquote><p>于是，显然有 $g$ 与 $f$ 的关系式：<br>$$<br>g_n &#x3D; \sum_{i&#x3D;n}^m\binom{i}{n}f_i<br>$$<br>于是我们可以根据二项式反演轻松写出 ：<br>$$<br>f_n &#x3D; \sum_{i&#x3D;n}^m\binom{i}{n}(-1)^{i-n}g_i<br>$$<br>于是只需要求出 $g_k$ 即可。</p><p>这里需要用到 <strong>树形背包</strong>，我们设 $dp_{u,k}$ 表示 $u$ 子树内钦定 祖先-儿子 点对的数量为 $k$ 时的方案数，那么显然在子树内有转移：<br>$$<br>f_{u,k} &#x3D; \sum_{\begin{matrix}\sum k_v &#x3D; k \ v\in son_u\end{matrix}} \prod f_{v,k_v}<br>$$<br>枚举子树一个一个乘起来即可，这一部分精细实现可以达到 $O(n^2)$。</p><p>然后我们再考虑当前节点 $u$。显然，当前节点 $u$ 可以与异色节点产生一个贡献，我们枚举 $k$，不难得到转移方程：<br>$$<br>f_{u,k} &#x3D; f_{u,k} + f_{u,k-1}\times (sz_{!col_u} - (k-1))<br>$$<br>这是因为 $u$ 可以跟所有异色节点产生贡献，而因为贡献只能产生 $1$，于是会有 $k-1$ 个异色节点用掉了，剩下的 $sz_{!col_u}-(k-1)$ 个点徐阿换一个即可。</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, dp[N][N], siz[N], sz[N], f[N], g[N], m, tmp[N], fact[N], infact[N];</span><br><span class="line"><span class="type">bool</span> bl[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">siz[x] = <span class="number">1</span>, sz[x] = bl[x];</span><br><span class="line">dp[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y:v[x])&#123;</span><br><span class="line"><span class="keyword">if</span>(y == fa)<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(y, x);</span><br><span class="line">siz[x] += siz[y], sz[x] += sz[y];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=siz[x];++i)tmp[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="built_in">min</span>(siz[x], m); ++i) <span class="keyword">if</span>(dp[x][i])</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j+i&lt;=m &amp;&amp; j&lt;=siz[y]; ++j) <span class="keyword">if</span>(dp[y][j])</span><br><span class="line">tmp[i+j] = (tmp[i+j] + dp[x][i] * dp[y][j] % MOD) % MOD;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=siz[x];++i)dp[x][i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(sz[x], siz[x] - sz[x]); i; --i)</span><br><span class="line">dp[x][i] = (dp[x][i] + dp[x][i<span class="number">-1</span>]*((bl[x] ? siz[x] - sz[x] : sz[x]) - (i<span class="number">-1</span>))%MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(; m; m&gt;&gt;=<span class="number">1</span>, x=x*x%MOD)<span class="keyword">if</span>(m &amp; <span class="number">1</span>)ans=ans*x%MOD;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fact[n]*infact[n-m]%MOD*infact[m]%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;(s+<span class="number">1</span>); m = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)fact[i] = fact[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">infact[n] = <span class="built_in">ksm</span>(fact[n], MOD<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)infact[i] = infact[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%MOD;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)bl[i] = s[i] == <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i)cin&gt;&gt;x&gt;&gt;y, v[x].<span class="built_in">pb</span>(y), v[y].<span class="built_in">pb</span>(x);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;++i)f[i] = dp[<span class="number">1</span>][i]*fact[m-i]%MOD;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=m;++j)</span><br><span class="line">g[i] = (g[i]+((j-i&amp;<span class="number">1</span>) ? MOD<span class="number">-1</span> : <span class="number">1</span>)*<span class="built_in">C</span>(j, i)%MOD*f[j]%MOD)%MOD;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;++i)cout&lt;&lt;g[i]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二项式反演&quot;&gt;&lt;a href=&quot;#二项式反演&quot; class=&quot;headerlink&quot; title=&quot; 二项式反演&quot;&gt;&lt;/a&gt;&lt;center&gt; 二项式反演&lt;/center&gt;&lt;/h1&gt;&lt;h2 id=&quot;前置：组合数学基础&quot;&gt;&lt;a href=&quot;#前置：组合数学基础&quot; cl</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CF615D 题解</title>
    <link href="http://example.com/2024/07/01/CF615D%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2024/07/01/CF615D%E9%A2%98%E8%A7%A3/</id>
    <published>2024-07-01T13:30:21.000Z</published>
    <updated>2024-07-01T13:31:05.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CF615D题解"><a href="#CF615D题解" class="headerlink" title="CF615D题解"></a>CF615D题解</h1><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>以给定质因子的形式给定一个数 $n$，并给出具体的质因子，求：</p><p>$$\prod_{d\mid n}d$$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>我们唯一分解 $n$，使得 $n&#x3D;\prod p_i^{\alpha_i}$，我们考虑对于每一个素数 $p_i$，它在质因子中可能以 $p_i^k(0\le k\le \alpha_i)$ 的形式出现，即一共 $\frac{\alpha_i\times(\alpha_i+1)}{2}$ 次。并且对于每个幂 $k$，都会在别的质因子取任何值的时候出现，即对于一个 $p_i^k$，它会出现 $\frac{\prod_j(\alpha_j+1)}{\alpha_i+1}$ 次，因此它的贡献就是</p><p>$$p_i^{\frac{\prod_j(\alpha_j+1)}{\alpha_i+1}\times\frac{\alpha_i\times(\alpha_i+1)}{2}}&#x3D;p_i^{\frac{\alpha_i\prod(\alpha_i+1)}{2}}$$</p><p>这个东西就计算 $\prod(\alpha_i+1)$，然后每次乘 $\alpha_i$ 放在 $p_i$ 的指数上。</p><p>记 $s&#x3D;\prod(\alpha_i+1)$，于是现在的答案就是</p><p>$$\prod p_i^{\frac{s\times \alpha_i}{2}}$$</p><p>但是 $s\times \alpha_i$ 可能会非常大，而且它在指数上，因此我们用拓展欧拉公式对指数进行降幂。</p><p>因为 $\alpha_i$ 与 $\alpha_i+1$ 都在乘积中，因此除以二一定为整数。但对于模数的情况下，我们并不能保证是整数，因此我们还需要进行判断。</p><ul><li><p>对于 $\alpha_i+1$ 有偶数的情况，再求乘积的时候就将某个 $\alpha_i+1$ 除以二，后面直接乘 $\alpha_i$ 就行。</p></li><li><p>对于 $\alpha_i+1$ 全部为奇数，即 $\alpha_i$ 全部为偶数，直接在最后计算的时候将 $\alpha_i$ 除以二再乘进去就可以了。</p></li></ul><p>具体的看代码吧。</p><h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,phi=MOD<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> t[N],cnt,sum=<span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&amp;<span class="number">1</span>)ans=ans*x%MOD;</span><br><span class="line">x=x*x%MOD; k&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;++i)cin&gt;&gt;x, t[x]++, m=<span class="built_in">max</span>(m,x);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>((t[i]+<span class="number">1</span>)%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;!flag)sum=sum*(t[i]+<span class="number">1</span>)/<span class="number">2</span>%phi, flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span>sum=sum*(t[i]+<span class="number">1</span>)%phi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(t[i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="keyword">if</span>(flag)y=sum*t[i]%phi;</span><br><span class="line"><span class="keyword">else</span>y=sum*t[i]/<span class="number">2</span>%phi;</span><br><span class="line">ans=ans*<span class="built_in">ksm</span>(i,y+phi)%MOD;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CF615D题解&quot;&gt;&lt;a href=&quot;#CF615D题解&quot; class=&quot;headerlink&quot; title=&quot;CF615D题解&quot;&gt;&lt;/a&gt;CF615D题解&lt;/h1&gt;&lt;h3 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="题解笔记" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Counting Arrays 题解</title>
    <link href="http://example.com/2024/07/01/Counting%20Arrays/"/>
    <id>http://example.com/2024/07/01/Counting%20Arrays/</id>
    <published>2024-07-01T13:30:21.000Z</published>
    <updated>2024-07-01T13:30:50.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Counting-Arrays"><a href="#Counting-Arrays" class="headerlink" title="Counting Arrays"></a>Counting Arrays</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定数 $x,y$ 求序列 $a_y$ 的个数使得 $\prod_{i&#x3D;1}^ya_i&#x3D;x$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>要将 $n$ 个完全一样的小球放进 $m$ 个盒子里面，要求不能有空盒子，就可以在 $n-1$ 个缝隙中插入 $m-1$ 个板子将 $n$ 分成 $m$ 份，于是容易得到方案数为 $\binom{n-1}{m-1}$。</p><p>但如果每个盒子中可以为空，就可以再加入 $m$ 个小球使得每个盒子必然被分到一个，然后在这 $n+m$ 个小球中插入 $m-1$ 块板子，于是最后答案就变成 $\binom{n+m-1}{m-1}$.</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>设 $x&#x3D;\prod_{i&#x3D;1}^kp_i^{\alpha_i}$，那么我们可以将这 $\sum\alpha_i$ 个质因数扔给 $y$ 个盒子，注意到这些质因子可能不同，因此不能整体使用插板法求方案数，而应该每个 $\alpha_i$ 分别做一次插板再乘起来。即答案为：</p><p>$$\prod \binom{\alpha_i+y-1}{y-1}$$</p><p>但注意到 $a_i$ 可以为负数，这样我们就可以令前 $y-1$ 个数可以正也可以负，最后一个来决定整个乘积的正负性，即答案有多乘以 $2^{y-1}$。</p><p>于是最终的答案就是:</p><p>$$2^{y-1}\times \prod\binom{\alpha_i+y-1}{y-1}$$</p><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t,x,y,fact[N],infact[N],p[N],prime[N],cnt,minn[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(m)&#123;</span><br><span class="line"><span class="keyword">if</span>(m&amp;<span class="number">1</span>)ans=ans*x%MOD;</span><br><span class="line">x=x*x%MOD; m&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fact[n]*infact[n-m]%MOD*infact[m]%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prime</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1000000</span>;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!prime[i])prime[++cnt]=i, minn[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=<span class="number">1000000</span>;++j)&#123;</span><br><span class="line">prime[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">minn[i*prime[j]]=prime[j];</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">Prime</span>();</span><br><span class="line">fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-10</span>;++i)fact[i]=fact[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">infact[N<span class="number">-10</span>]=<span class="built_in">ksm</span>(fact[N<span class="number">-10</span>],MOD<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=N<span class="number">-11</span>;i&gt;=<span class="number">0</span>;--i)infact[i]=infact[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%MOD;</span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000000</span>;++i)p[i]=p[i<span class="number">-1</span>]*<span class="number">2</span>%MOD;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="type">int</span> ans=p[y<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">while</span>(x&gt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>, xx=x;</span><br><span class="line"><span class="keyword">while</span>(xx%minn[x]==<span class="number">0</span>)xx/=minn[x], ++sum;</span><br><span class="line">ans=ans*<span class="built_in">C</span>(sum+y<span class="number">-1</span>,y<span class="number">-1</span>)%MOD;</span><br><span class="line">x=xx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x!=<span class="number">1</span>)ans=ans*<span class="built_in">C</span>(y,y<span class="number">-1</span>)%MOD;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Counting-Arrays&quot;&gt;&lt;a href=&quot;#Counting-Arrays&quot; class=&quot;headerlink&quot; title=&quot;Counting Arrays&quot;&gt;&lt;/a&gt;Counting Arrays&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="题解笔记" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯反演</title>
    <link href="http://example.com/2024/07/01/Mobius%20Inversion/"/>
    <id>http://example.com/2024/07/01/Mobius%20Inversion/</id>
    <published>2024-07-01T13:30:21.000Z</published>
    <updated>2024-07-01T13:32:03.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><h2 id="反演"><a href="#反演" class="headerlink" title="反演"></a>反演</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>假如对于 $f$ 有线性变换：</p><p>$$\begin{cases}F(1) &#x3D; f(1)\ F(2) &#x3D; f(1) + f(2)\ F(3) &#x3D; f(1) + f(3)\ \vdots\F(n) &#x3D; \sum\limits_{d\mid n}f(d)\end{cases}$$</p><p>我们想要知道 $F$ 反推 $f$，那么我们就需要一种运算叫做 <strong>反演</strong>。</p><p>同样地，我们举几个例子：</p><p>$$\begin{cases}f(1) &#x3D; F(1)\ f(2) &#x3D; F(2) - F(1)\ f(3) &#x3D; F(3) - F(1)\ f(4) &#x3D; F(4) - F(2)\ \vdots\ f(n) &#x3D; \sum\limits_{d\mid n} \mu(\frac{n}{d})F(d)\end{cases}$$</p><p>其中，$\mu(n)$ 是一个数论函数，它代表着 $f(n)$ 的系数，可以的取值有 $1,0,-1$。</p><h2 id="引入函数"><a href="#引入函数" class="headerlink" title="引入函数"></a>引入函数</h2><h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><h4 id="定义1"><a href="#定义1" class="headerlink" title="定义1"></a>定义1</h4><p>$$\mu(x)&#x3D;\begin{cases}1, &amp;x&#x3D;1\(-1)^k, &amp;x&#x3D;\prod\limits_{i&#x3D;1}^kp_k\0, &amp;\mathrm{otherwise}\end{cases}$$</p><h4 id="性质1-1"><a href="#性质1-1" class="headerlink" title="性质1.1"></a>性质1.1</h4><p>它是一个积性函数，即对于 $p,q$，若 $\gcd(p,q)&#x3D;1$，则 $\mu(p\times q)&#x3D;\mu(p)\times \mu(q)$。</p><blockquote><p><strong>证明</strong></p><p>对于 $p&#x3D;1$ 的情况，显然 $\mu(1\cdot x)&#x3D;\mu(x)\cdot\mu(1)$</p><p>否则，若 $p,q$ 中有一个数有平方因子，那么整个 $p\cdot q$ 必然有平方因子，故 $\mu(p\cdot q)&#x3D;\mu(p)*\mu(q)&#x3D;0$。</p><p>对于一般情况，设 $p&#x3D;\prod\limits_{i&#x3D;1}^{k_1}p_i,q&#x3D;\prod\limits_{i&#x3D;1}^{k_2}p_i$，那么 $\mu(p)&#x3D;(-1)^{k_1},\mu(q)&#x3D;(-1)^{k_2}$，而 $\gcd(p,q)&#x3D;1$，所以 $p\cdot q&#x3D;\prod\limits_{i&#x3D;1}^{k_1+k_2}p_i,mu(p\cdot q)&#x3D;(-1)^{(k_1+k_2)}&#x3D;(-1)^{k_1}\cdot (-1)^{k_2}&#x3D;\mu(p)\cdot \mu(q)$。</p><p>证毕</p></blockquote><h4 id="性质1-2"><a href="#性质1-2" class="headerlink" title="性质1.2"></a>性质1.2</h4><p>$$\sum\limits_{d\mid n}\mu(d)&#x3D;\epsilon(n)$$</p><p>这定理也可以写成 $\mu \ast 1&#x3D;\epsilon$。其中 $\ast$ 是狄利克雷卷积。</p><blockquote><p>证明</p><p>显然，性质 1.2 等价于：</p><p>$$\sum_{d\mid x}\mu(d)&#x3D;\begin{cases}1, &amp;x&#x3D;1\ 0, &amp;\text{otherwise}\end{cases}$$</p><p>容易证明 $x&#x3D;1$ 时该命题成立。</p><p>对于 $x\not &#x3D;1$ 的情况，我们设 $x&#x3D;\prod_{i&#x3D;1}^k p_i^{\alpha_i}$。容易想到所有能够产生贡献的因子都是这 $k$ 个因子的不重复组合，因为有平方的因子的莫比乌斯函数值为0。其中，有 $i$ 个质因子的因子有 $\binom{k}{i}$ 个。由此不难看出原式 $&#x3D;\sum_{i&#x3D;0}^k (-1)^i\binom{k}{i}$。下面分两种情况讨论：</p><ul><li><p>$k$ 为偶数。</p><p>根据公式 $\binom{n}{m}&#x3D;\binom{n-1}{m}+\binom{n-1}{m-1}$，那么原式 $&#x3D;\binom{k}{0}-\binom{k}{1}+\binom{k}{2}-\cdots+\binom{k}{k}&#x3D;(\binom{k-1}{0})-(\binom{k-1}{0}+\binom{k-1}{1})+(\binom{k-1}{1}+\binom{k-1}{2})-\cdots-(\binom{k-1}{k-2}+\binom{k-1}{k-1})+(\binom{k-1}{k-1})$.容易看出两两抵消，最后结果为0。</p></li><li><p>$k$ 为奇数。</p><p>那么 $i$ 与 $k-i$ 奇偶性不同，而 $\binom{k}{i}&#x3D;\binom{k}{k-i}$，因此两两抵消，最终结果为 $0$。</p></li></ul><p>证毕。</p></blockquote><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><h4 id="定义2"><a href="#定义2" class="headerlink" title="定义2"></a>定义2</h4><p>$$\varphi(x)&#x3D;\sum\limits_{i&#x3D;1}^x[\gcd(i,x)&#x3D;1]$$</p><p>欧拉函数反映了一个数与小于等于它并且与它互质的数的个数。</p><h4 id="性质2-1"><a href="#性质2-1" class="headerlink" title="性质2.1"></a>性质2.1</h4><p>它也是个积性函数，这里我们不证。另外，我们可以写出它的通项公式：$\varphi(x)&#x3D;\prod\limits_{i&#x3D;1}^k(1-\frac{1}{p_i})$。</p><blockquote><p><strong>证明</strong></p><p>设 $x$ 能够质因数分解为 $x&#x3D;\prod\limits_{i&#x3D;1}^{m}p_i^{\alpha_i}$，让 $x$ 减去所有 $p_i$ 的倍数得到 $n-\sum\limits_{i&#x3D;1}^m\left\lfloor\frac{n}{p_i}\right\rfloor$。但是这并不是最终答案，因为还有 $p_i\times p_{i+1}$ 的倍数被算了两边。没错就是容斥原理。然后最终答案就是 $n+\sum\limits_{i&#x3D;1}^{m}(-1)^{i}\sum\limits_{j&#x3D;1}^{k-i+1}\prod\limits_{k&#x3D;j}^{j+i-1}p_k$。最终因式分解就可以得到原式。</p><p>证毕</p></blockquote><p>其实，写出通项公式和之后已经很容易证明它是积性函数了。</p><h3 id="因子函数"><a href="#因子函数" class="headerlink" title="因子函数"></a>因子函数</h3><h4 id="定义3"><a href="#定义3" class="headerlink" title="定义3"></a>定义3</h4><p>$\sigma(x)&#x3D;\sum\limits_{d\mid n}d$。</p><p>它表示了一个数的因子和。</p><h4 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h4><p>它也是积性函数。</p><blockquote><p><strong>证明</strong></p><p>设 $\sum\limits_{d\mid p}d&#x3D;\sum\limits_{i&#x3D;1}^na_i, \sum\limits_{d\mid q}d&#x3D;\sum\limits_{i&#x3D;1}^mb_i$。其中，因为 $\gcd(p,q)&#x3D;1$，所以 ${a_n}$ 中的元素与 ${b_n}$ 中的互不相同。那么将 ${a_n}$ 与 ${b_n}$ 两两组合就可以补充不漏地得到 $p\cdot q$ 的所有因子，即 $\sigma(p\cdot q)&#x3D;(\sum\limits_{i&#x3D;1}^na_i)(\sum\limits_{i&#x3D;1}^mb_i)&#x3D;\sigma(p)\cdot \sigma(q)$。</p><p>证毕</p></blockquote><h3 id="恒等函数"><a href="#恒等函数" class="headerlink" title="恒等函数"></a>恒等函数</h3><h4 id="定义4"><a href="#定义4" class="headerlink" title="定义4"></a>定义4</h4><p>$$\operatorname{1}(x)&#x3D;1$$</p><p>这个我就不想多说了，其中重要的一点事它是完全积性函数，即对于 $\forall a,b\in \mathbb{N}^{\ast}$，都满足 $\operatorname{1}(a\cdot b)&#x3D;\operatorname{1}(a)\cdot \operatorname{1}(b)$。</p><h3 id="元函数"><a href="#元函数" class="headerlink" title="元函数"></a>元函数</h3><h4 id="定义5"><a href="#定义5" class="headerlink" title="定义5"></a>定义5</h4><p>$$\epsilon(x)&#x3D;[x&#x3D;1]$$</p><p>即这个函数返回 $x$ 是否为 $1$。显然，它也是完全积性函数。</p><h4 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h4><p>对于任意函数 $f(x)$，它与 $\epsilon$ 的狄利克雷卷积 $f*\epsilon&#x3D;f$。这个请读着自证。</p><h3 id="单位函数"><a href="#单位函数" class="headerlink" title="单位函数"></a>单位函数</h3><h4 id="定义6"><a href="#定义6" class="headerlink" title="定义6"></a>定义6</h4><p>$$\operatorname{Id}(x)&#x3D;x$$</p><p>它返回的是自变量本身。同样，它是完全积性函数。</p><h2 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h2><p>我们定义：两个函数 $f(x),g(x)$ 间的运算 $\sum\limits_{d|n}f(n)\cdot g(\frac{n}{d})$ 计为 $(f*g)(x)$，称为狄利克雷卷积。它满足交换律、结合律和对加法的分配率。</p><h2 id="结论及证明"><a href="#结论及证明" class="headerlink" title="结论及证明"></a>结论及证明</h2><p>若函数 $F(x)&#x3D;\sum\limits_{d\mid x}f(d)$，则 $f(x)&#x3D;\sum\limits_{d\mid x}\mu(d)F(\frac{x}{d})$ 或 $f(x)&#x3D;\sum\limits_{d\mid x}\mu(\frac{x}{d})F(d)$。这定理又可以写成设 $F&#x3D;f\ast\operatorname{1}$，则 $f&#x3D;F\ast\mu$。</p><blockquote><p><strong>证明</strong></p><p>由 $\mu\ast\operatorname{1}&#x3D;\epsilon$ 和 $F&#x3D;f\ast\operatorname{1}$ 进行推导。</p><p>由 $F&#x3D;f\ast\operatorname{1}$ 可得 $F\ast\mu&#x3D;f\ast\operatorname{1}\ast \mu$，再由 $\mu * 1&#x3D;\epsilon$ 可得 $F<em>\mu&#x3D;f</em>\epsilon&#x3D;f$。</p><p>即 $F*\mu&#x3D;f$。</p><p>证毕</p></blockquote><p>由此可以推导出两条重要结论：</p><ol><li>$\epsilon(n)&#x3D;\sum\limits_{d\mid n}\mu(d)$，也就是 $\epsilon&#x3D;\mu*\operatorname{1}$。</li><li>$n&#x3D;\sum\limits_{d\mid n}\varphi(d)$，也即 $\operatorname{Id}&#x3D;\varphi<em>\operatorname{1}$，或 $\mu</em>\operatorname{Id}&#x3D;\varphi$。</li></ol><p>第一条我们在补充函数- $\mu$ 函数中已经证明，下面给出第二条的证明。</p><blockquote><p><strong>证明</strong></p><p>由欧拉函数的定义得到 $\varphi(n)&#x3D;\sum\limits_{i&#x3D;1}^n[\gcd(i,n)&#x3D;1]&#x3D;\sum\limits_{i&#x3D;1}^n\epsilon(\gcd(i,n))$，由第一条得到原式 $&#x3D;\sum\limits_{i&#x3D;1}^n\sum\limits_{d\mid i,d\mid n}\mu(d)$，改变求和顺序，能够得到原式 $&#x3D;\sum\limits_{d\mid n} \mu(d)\sum\limits_{d\mid i} 1&#x3D;\sum\limits_{d\mid n}\mu(d)\frac{n}{d}&#x3D;\sum\limits_{d\mid n}\mu(d)\operatorname{Id}(\frac{n}{d})$，然后反过来就得到 $\operatorname{Id}&#x3D;\varphi*\operatorname{1}$。</p><p>证毕</p></blockquote><h2 id="小技巧：整除分块"><a href="#小技巧：整除分块" class="headerlink" title="小技巧：整除分块"></a>小技巧：整除分块</h2><h3 id="求：-sum-limits-i-1-n-left-lfloor-frac-n-i-right-rfloor"><a href="#求：-sum-limits-i-1-n-left-lfloor-frac-n-i-right-rfloor" class="headerlink" title="求：$\sum\limits_{i&#x3D;1}^n\left\lfloor\frac{n}{i}\right\rfloor$"></a>求：$\sum\limits_{i&#x3D;1}^n\left\lfloor\frac{n}{i}\right\rfloor$</h3><p>我们注意到：$\left\lfloor\frac{n}{i}\right\rfloor$ 的取值至多只有 $O(\sqrt n)$ 的数量级，因此我们只需要知道每个取值有多少个 $i$ 能够取到就可以在 $O(\sqrt{n})$ 内求出这个值。如何快速求出有多少个 $i$ 能取到呢？下面给出定理：</p><p>定理：$\frac{n}{i}$ 的取值中能够取到最大的 $i$ 是 $\left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor}\right\rfloor$。</p><p>下面给出证明：</p><blockquote><ul><li><p>充分性：设 $j&#x3D;\left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor}\right\rfloor$，那么显然有 $\left\lfloor\frac{n}{j}\right\rfloor&#x3D;\left\lfloor\frac{n}{\left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor}\right\rfloor}\right\rfloor&#x3D;\left\lfloor\frac{n}{i}\right\rfloor$</p></li><li><p>必要性：因为 $\left\lfloor\frac{n}{i}\right\rfloor&#x3D;\left\lfloor\frac{n}{j}\right\rfloor$，所以 $\left\lfloor\frac{n}{j}\right\rfloor\ge\left\lfloor\frac{n}{i}\right\rfloor$，即 $\frac{n}{j}\ge\left\lfloor\frac{n}{i}\right\rfloor$。</p><p>两边同取倒数，得到 $\frac{j}{n}\le\frac{1}{\left\lfloor\frac{n}{i}\right\rfloor}$,最后同乘以 $n$ 得到 $j\le \left\lfloor\frac{n}{\left\lfloor\frac{n}{i}\right\rfloor}\right\rfloor$。</p></li></ul><p>证毕。</p></blockquote><h3 id="进阶：求-sum-i-cdot-left-lfloor-frac-n-i-right-rfloor"><a href="#进阶：求-sum-i-cdot-left-lfloor-frac-n-i-right-rfloor" class="headerlink" title="进阶：求 $\sum i\cdot\left\lfloor\frac{n}{i}\right\rfloor$"></a>进阶：求 $\sum i\cdot\left\lfloor\frac{n}{i}\right\rfloor$</h3><p>我们拆分一下，把所有结果一致的 $i$ 提出来，能够得到原式 $&#x3D;\sum\limits_{k&#x3D;i}^j k\times \left\lfloor\frac{n}{k}\right\rfloor$，其中 $i,j$ 满足 $\left\lfloor\frac{n}{i}\right\rfloor&#x3D;\left\lfloor\frac{n}{j}\right\rfloor$，且 $i,j$ 分别是这个取值区间的左右端点。因此 $\Leftrightarrow\left\lfloor\frac{n}{i}\right\rfloor\sum\limits_{k&#x3D;i}^j k&#x3D;\left\lfloor\frac{n}{i}\right\rfloor\cdot\frac{(i+j)(j-i+1)}{2}$。</p><p>由此不难看出对于求 $\sum\limits_{i&#x3D;1}^nf(i)\times \left\lfloor\frac{n}{i}\right\rfloor$ 的问题，可以直接将 $\frac{n}{i}$ 相等的 $i$ 取值写成 $\frac{n}{i}\times (s_j-s_{i-1})$，其中 $s_n&#x3D;\sum\limits_{i&#x3D;1}^nf(i)$。</p><h2 id="线性筛法求-mu-函数"><a href="#线性筛法求-mu-函数" class="headerlink" title="线性筛法求 $\mu$ 函数"></a>线性筛法求 $\mu$ 函数</h2><p>性质2：$\mu(x\cdot p)&#x3D;-\mu(x)$，其中 $p$ 为素数且 $p\not\ \mid x$。</p><p>这个定理读者自证即可。</p><p>由此，这性质很适配线性筛。在 <code>i%p[j]==0</code> 时令 <code>mu[i*p[j]]=0</code> 即可，因为至少含有一个完全平方因子 $p^2$。再其它时候都有 <code>i%p[j]!=0</code>，应用性质 2 不难得出 <code>mu[i*p[j]]=-mu[i]</code>。</p><p>下面看几道例题：</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h3><p>求 $\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m[\gcd(i,j)&#x3D;1]$。</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h3><p>容易看出 $[\gcd(i,j)&#x3D;1]\Leftrightarrow \epsilon(\gcd(i,j))$，又根据 $\epsilon&#x3D;\mu *1$ 不难得到 $\epsilon(\gcd(i,j))\Leftrightarrow \sum\limits_{d\mid \gcd(i,j)}\mu(d)\Leftrightarrow \sum\limits_{d\mid i,d\mid j}\mu(d)$。因此原式可以写成</p><p>$$\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m\sum\limits_{d\mid i,d\mid j}\mu(d)$$</p><p>我们改变枚举顺序首先枚举 $d$ 就能够得到</p><p>$$\sum\limits_{d&#x3D;1}^{\min(n,m)}\mu(d)\sum\limits_{d\mid i}^n\sum\limits_{d\mid j}^m1&#x3D;\sum\limits_{d&#x3D;1}^{\min(n,m)}\mu(d)\left\lfloor\frac{n}{d}\right\rfloor\left\lfloor\frac{m}{d}\right\rfloor$$</p><p>于是 $O(\sqrt n)$ 内即可完成一次询问。</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><p>求 $\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m[\gcd(i,j)&#x3D;k]$</p><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>这里先把 $k$ 提出得到</p><p>$$\sum\limits_{i&#x3D;1}^{\left\lfloor\frac{n}{k}\right\rfloor}\sum\limits_{j&#x3D;1}^{\left\lfloor\frac{m}{k}\right\rfloor}[\gcd(i,j)&#x3D;1]$$</p><p>然后按照例 1 就可以得到答案。</p><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><p>设素数集合为 $\mathcal{P}$，求 $\sum\limits_{k\in \mathcal{P}}\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m[\gcd(i,j)&#x3D;k]$</p><h3 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h3><p>首先按照例 2 把二三层求和化简成</p><p>$$\sum\limits_{k\in \mathcal{P}}\sum\limits_{d&#x3D;1}^{\min(\left\lfloor\frac{n}{k}\right\rfloor,\left\lfloor\frac{m}{k}\right\rfloor)}\mu(d)\left\lfloor\frac{n}{k\times d}\right\rfloor\left\lfloor\frac{m}{k\times d}\right\rfloor$$</p><p>然后有一个常用的小技巧，我们枚举 $T&#x3D;k\times d$，得到</p><p>$$\sum\limits_{T&#x3D;1}^{\min(n,m)}\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor\sum\limits_{k\in \mathcal{P},k\mid T}\mu(\frac{T}{k})$$</p><p>注意到最后一个求和是可以预处理的，它只与一个变量 $T$ 有关，我们枚举 $k\in \mathcal{P}$ 然后给它的 $i$ 倍加上 $\mu(i)$ 即可。</p><h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><p>求 $\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^md(ij)$，其中 $d(x)&#x3D;\sum\limits_{d\mid x}1$。</p><h3 id="Solution4"><a href="#Solution4" class="headerlink" title="Solution4"></a>Solution4</h3><p>首先摆出公式 $d(i,j)&#x3D;\sum\limits_{x\mid i}\sum\limits_{y\mid j}[\gcd(x,y)&#x3D;1]$。</p><p>于是式子就变成了</p><p>$$\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m\sum\limits_{x\mid i}\sum\limits_{y\mid j}[\gcd(x,y)&#x3D;1]$$</p><p>先枚举 $x,y$ 得到</p><p>$$\sum\limits_{x&#x3D;1}^n\sum\limits_{y&#x3D;1}^m\left\lfloor\frac{n}{x}\right\rfloor\left\lfloor\frac{m}{y}\right\rfloor\epsilon(\gcd(x,y))$$</p><p>按习惯改写 $x,y$ 为 $i,j$，然后把 $\epsilon$ 莫比乌斯反演，得到：</p><p>$$\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m\left\lfloor\frac{n}{i}\right\rfloor\left\lfloor\frac{m}{j}\right\rfloor\sum\limits_{d\mid i,d\mid j}\mu(d)$$</p><p>改而枚举 $d$ 得到</p><p>$$\sum\limits_{d&#x3D;1}^{\min(n,m)}\mu(d)\sum\limits_{i&#x3D;1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum\limits_{j&#x3D;1}^{\left\lfloor\frac{m}{d}\right\rfloor}\left\lfloor\frac{n}{i}\right\rfloor\left\lfloor\frac{m}{j}\right\rfloor&#x3D;\sum\limits_{d&#x3D;1}^{\min(n,m)}\mu(d)(\sum\limits_{i&#x3D;1}^{\left\lfloor\frac{n}{d}\right\rfloor}\left\lfloor\frac{n}{i}\right\rfloor)(\sum\limits_{j&#x3D;1}^{\left\lfloor\frac{m}{d}\right\rfloor}\left\lfloor\frac{m}{j}\right\rfloor)$$</p><p>最后套上整除分治就可以在 $O(T\times \sqrt N)$ 内得到答案。</p><p>关于 $d(ij)&#x3D;\sum\limits_{x\mid i}\sum\limits_{y\mid j}[\gcd(i,j)&#x3D;1]$ 的证明：</p><blockquote><p><strong>证明</strong></p><p>我们考虑对 $ij$ 的每一个因子进行唯一映射，即构建自变量为 $ij$ 的因子的函数。显然，如果一个因子包含 $p^{\alpha_1}$，而 $i$ 中含有 $p^{\alpha_2}$，$j$ 中含有 $p^{\alpha_3}$，那么当 $\alpha_2&gt;\alpha_1$ 时，我们规定用所有的 $i$ 中的 $p$，否则规定用 $\alpha_1-\alpha_2$ 个 $j$ 的 $p$，这样分别计为 $i_{\alpha_2}$ 和 $j_{\alpha_1-\alpha_2}$，因此 $i$ 与 $j$ 不会同时出现一个因子，即枚举到的两个因子互质。</p><p>证毕。</p></blockquote><h3 id="例题5"><a href="#例题5" class="headerlink" title="例题5"></a>例题5</h3><p>有 $t$ 次询问，每一次询问包含两个数 $n,m$，求：</p><p>$$\prod_{i&#x3D;1}^n\prod_{j&#x3D;1}^mf_{\gcd(i,j)}\pmod {10^9+7}$$</p><p>其中 $f_x$ 表示的是斐波那契数列。即：</p><p>$$f_n&#x3D;\begin{cases}0, &amp;x&#x3D;0\ 1, &amp; x&#x3D;1\ f_{n-1}+f_{n-2}, &amp;x\ge 2\end{cases}$$</p><h3 id="Solution5"><a href="#Solution5" class="headerlink" title="Solution5"></a>Solution5</h3><p>首先，我们考虑枚举 $d &#x3D; \gcd(i,j)$：</p><p>$$\begin{equation}\begin{aligned}\prod_{i&#x3D;1}^n\prod_{j&#x3D;1}^mf_{\gcd(i,j)}&amp;&#x3D;\prod_{d&#x3D;1}^n\prod_{i&#x3D;1}^n\prod_{j&#x3D;1}^m[\gcd(i,j)&#x3D;d]f_{\gcd(i,j)}\&amp;&#x3D;\prod_{d&#x3D;1}^nf_{d}^{\sum\limits_{i&#x3D;1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum\limits_{j&#x3D;1}^{\left\lfloor\frac{m}{d}\right\rfloor}[\gcd(i,j)&#x3D;1]}\end{aligned}\nonumber\end{equation}$$</p><p>单独拿出来指数的部分，得到：</p><p>$$\begin{equation}\begin{aligned}\sum_{i&#x3D;1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j&#x3D;1}^{\left\lfloor\frac{m}{d}\right\rfloor}[\gcd(i,j)&#x3D;1]&#x3D;&amp;\sum_{x&#x3D;1}^{\left\lfloor\frac{n}{d}\right\rfloor}\mu(x)\left\lfloor\frac{n}{dx}\right\rfloor\left\lfloor\frac{m}{dx}\right\rfloor\end{aligned}\nonumber\end{equation}$$</p><p>显然，这个式子可以整除分块，然后外面再套一层整除分块和一个快速幂，就完成了 $O(n\log n)$ 处理一次询问。但是仍然不够。</p><p>考虑设 $T &#x3D; dx$，于是有</p><p>$$\begin{equation}\begin{aligned}<br>\prod_{d&#x3D;1}^nf_{d}^{\sum\limits_{x&#x3D;1}^{\left\lfloor\frac{n}{d}\right\rfloor}\mu(x)\left\lfloor\frac{n}{dx}\right\rfloor\left\lfloor\frac{m}{dx}\right\rfloor}<br>&#x3D;&amp;\prod_{T&#x3D;1}^n\prod_{d\mid T}f_d^{\mu(\frac{T}{d})\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor}<br>\&#x3D;&amp;\prod_{T&#x3D;1}^n(\prod_{d\mid T}f_d^{\mu(\frac{T}{d})})^{\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor}<br>\end{aligned}\nonumber\end{equation}$$</p><p>这一步变换是因为我们把 $f_d$ 上的指数 $\sum\limits_{x&#x3D;1}^{\left\lfloor\frac{n}{d}\right\rfloor}\mu(x)\left\lfloor\frac{n}{dx}\right\rfloor\left\lfloor\frac{m}{dx}\right\rfloor$ 拆开来看。对于每一个 $d$ 的倍数 $kd$，我们令它贡献到 $f_d$ 的指数上一个 $\mu(k)\left\lfloor\frac{n}{kd}\right\rfloor\left\lfloor\frac{m}{kd}\right\rfloor$，也就和原来的式子是相等的。</p><p>这样，我们就可以预处理上式括号中括进去的东西，复杂度为调级数，而整体的复杂度变成 $O(\sqrt{n}\log n)$。于是正道题目的复杂度为 $O(T\sqrt n\log n + n\ln n)$。</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><h3 id="常用公式"><a href="#常用公式" class="headerlink" title="常用公式"></a>常用公式</h3><h4 id="最基本的公式"><a href="#最基本的公式" class="headerlink" title="最基本的公式"></a>最基本的公式</h4><p>首先，就是莫比乌斯反演的基本公式：</p><p>$$\mu\ast \operatorname{1}&#x3D;\epsilon$$</p><p>使用普通的形式，即：</p><p>$$[n&#x3D;1]&#x3D;\sum_{d\mid n}\mu(d)$$</p><h4 id="稍加变形"><a href="#稍加变形" class="headerlink" title="稍加变形"></a>稍加变形</h4><p>对于 $[n&#x3D;k]$ 的情况，我们可以把 $k$ 提出来，也就是看成 $[\frac{n}{k}&#x3D;1]$，即</p><p>$$[n&#x3D;k]&#x3D;[\frac{n}{k}&#x3D;1]&#x3D;\sum_{d\mid \frac{n}{k}}\mu(d)$$</p><h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>稍微加入一点应用，即求</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\epsilon(\gcd(i,j))$$</p><p>这个直接变形 $\epsilon$，然后改变枚举顺序即可：</p><p>$$\begin{equation}\begin{aligned}<br>\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\epsilon(\gcd(i,j))<br>&#x3D;&amp;\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n\sum_{d\mid i,d\mid j}\mu(d)<br>\&#x3D;&amp;\sum_{d&#x3D;1}^n\mu(d)\sum_{i&#x3D;1}^{id\le n}\sum_{j&#x3D;1}^{jd\le n}1<br>\&#x3D;&amp;\sum_{d&#x3D;1}^n\mu(d)\sum_{i&#x3D;1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j&#x3D;1}^{\left\lfloor\frac{n}{d}\right\rfloor}1<br>\&#x3D;&amp;\sum_{d&#x3D;1}^n\mu(d)\left\lfloor\frac{n}{d}\right\rfloor ^2<br>\end{aligned}\nonumber\end{equation}$$</p><h4 id="再加一点小技巧"><a href="#再加一点小技巧" class="headerlink" title="再加一点小技巧"></a>再加一点小技巧</h4><p>考虑求下面这个东西：</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n[\gcd(i,j)&#x3D;p]\ (p\in \mathcal{P})$$</p><p>显然，我们首先枚举 $p$：</p><p>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n[\gcd(i,j)&#x3D;p]\ (p\in \mathcal{P})&#x3D;\sum_{p&#x3D;1,p\in \mathcal{P}}^n\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n[\gcd(i,j)&#x3D;p]$$</p><p>然后莫比乌斯反演：</p><p>$$\begin{equation}\begin{aligned}\sum_{p&#x3D;1,p\in \mathcal{P}}^n\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^n[\gcd(i,j)&#x3D;p]&#x3D;&amp;\sum_{p&#x3D;1,p\in \mathcal{P}}^n\sum_{i&#x3D;1}^{\left\lfloor\frac{n}{p}\right\rfloor}\sum_{j&#x3D;1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{d\mid i,d\mid j}\mu(d)\&#x3D;&amp;\sum_{p&#x3D;1,p\in \mathcal{P}}^n\sum_{d&#x3D;1}^n\mu(d)\sum_{i&#x3D;1}^{\left\lfloor\frac{n}{pd}\right\rfloor}\sum_{j&#x3D;1}^{\left\lfloor\frac{n}{pd}\right\rfloor}1\&#x3D;&amp;\sum_{p&#x3D;1,p\in \mathcal{P}}^n\sum_{d&#x3D;1}^n\mu(d)\left\lfloor\frac{n}{pd}\right\rfloor^2\end{aligned}\nonumber\end{equation}$$</p><p>再然后。。。似乎优化不了了。但是我们可以设 $T&#x3D;pd$，然后转而枚举 $T$，就能够得到：</p><p>$$\sum_{p&#x3D;1,p\in \mathcal{P}}^n\sum_{d&#x3D;1}^n\mu(d)\left\lfloor\frac{n}{pd}\right\rfloor^2$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;莫比乌斯反演&quot;&gt;&lt;a href=&quot;#莫比乌斯反演&quot; class=&quot;headerlink&quot; title=&quot;莫比乌斯反演&quot;&gt;&lt;/a&gt;莫比乌斯反演&lt;/h1&gt;&lt;h2 id=&quot;反演&quot;&gt;&lt;a href=&quot;#反演&quot; class=&quot;headerlink&quot; title=&quot;反演&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>P3557 题解</title>
    <link href="http://example.com/2024/07/01/P3557%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2024/07/01/P3557%E9%A2%98%E8%A7%A3/</id>
    <published>2024-07-01T13:30:21.000Z</published>
    <updated>2024-07-01T13:32:14.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="P3557-题解"><a href="#P3557-题解" class="headerlink" title="P3557 题解"></a>P3557 题解</h1><h2 id="Des"><a href="#Des" class="headerlink" title="Des"></a>Des</h2><p>给定一张无向图，其中有 $n$ 个点 $m$ 条边，保证存在一个长度为 $k$ 的序列 $p_k$ 使得标记 $p_k$ 即 $p_k$ 一步能够到达的地方之后，所有的点都被标记。现在要求标记两步之内能够到达的点，求一种构造的方法使得所有点被标记。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>首先摆出结论：</p><blockquote><p>对于一张图，我们计 <code>vis[x]</code> 表示节点 $x$ 的标记情况。每一次更新的时候，我们找到一个 $x$ 使得 <code>vis[x]==false</code>，然后标记所有 $x$ 两步之内能够到达的点，最后统计一下我们进行了多少次操作即可。</p></blockquote><p>下面我们来 <strong>证明这个 <del>显而易见</del></strong> 的结论：</p><p>首先，对于原图，我们知道，对于任意一个点 $x$，总存在 $i\in [1,k]$ 使得 $\operatorname{dis}(x,p_i)&#x3D;1$ 或 $x&#x3D;p_i$。</p><ul><li>如果 $\operatorname{dis}(x,p_i)&#x3D;1$，则我们在这里标记一定会在距离为 $1$ 的地方标记到 $p_i$，进而标记 $p_i$ 原来标记到的点。这样显然不劣。</li><li>如果 $x&#x3D;p_i$，那么同样地，$x$ 可以标记到 $p_i$ 原来标记得到和一些原来标记不到的点，因此也是不劣的。</li></ul><p>又，对于每一个新标记的点，至少会覆盖到一个 $p_i$ 使得之后不需要再标记。因此新的标记的点的数量总不超过 $k$。</p><p>于是我们就可以遍历 $1-n$，遇到没有标记的就标记一下。但是注意要遍历所有的两个距离之内能够到达的点，否则可能会因为标记卡住了而无法继续标记新的节点。</p><p>但这样复杂度为什么是对的呢？</p><p>我们考虑对于一个点标记点 $p_i$，之后 $p_i$ 和 $p_i$ 一步能够到达的点会遍历一次所有的边。而它们周围一步能够到达的点都已经都标记完了，下一次再遍历到它们一定是距离标记点 $2$ 时。这时就不需要再遍历它们的边了。因此，每个点的边只会被遍历一次，这就保证了复杂度的正确性。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, k, st[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans, g[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> st)</span></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(st == <span class="number">2</span>)<span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y:g[x])<span class="built_in">dfs</span>(y, st+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;++i)cin&gt;&gt;x&gt;&gt;y, g[x].<span class="built_in">pb</span>(y), g[y].<span class="built_in">pb</span>(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">if</span>(!vis[i])ans.<span class="built_in">pb</span>(i), <span class="built_in">dfs</span>(i, <span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;ans.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x:ans)cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;P3557-题解&quot;&gt;&lt;a href=&quot;#P3557-题解&quot; class=&quot;headerlink&quot; title=&quot;P3557 题解&quot;&gt;&lt;/a&gt;P3557 题解&lt;/h1&gt;&lt;h2 id=&quot;Des&quot;&gt;&lt;a href=&quot;#Des&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="题解笔记" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>P1445 [Violet] 樱花 题解</title>
    <link href="http://example.com/2024/07/01/P1445%20[Violet]%20%E6%A8%B1%E8%8A%B1/"/>
    <id>http://example.com/2024/07/01/P1445%20[Violet]%20%E6%A8%B1%E8%8A%B1/</id>
    <published>2024-07-01T13:30:21.000Z</published>
    <updated>2024-07-01T13:30:37.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="P1445-Violet-樱花-题解"><a href="#P1445-Violet-樱花-题解" class="headerlink" title="P1445 [Violet] 樱花 题解"></a>P1445 [Violet] 樱花 题解</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给定正整数 $n$，求有多少组正整数有序数对 $(x,y)$ 满足 $\frac{1}{x}+\frac{1}{y}&#x3D;\frac{1}{n!}$。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="拆式子"><a href="#拆式子" class="headerlink" title="拆式子"></a>拆式子</h3><p>观察式子 $\frac{1}{x}+\frac{1}{y}&#x3D;\frac{1}{n!}$，同分后移项得到 $x\times y-n!\times (x+y)&#x3D;0$，注意到这个式子中既含有 $x$ 与 $y$ 的乘积又含有它们的和，想到韦达定理，因此两边添加二次项 $(n!)^2$，然后因式分解得到：</p><p>$$(n!-x)(n!-y)&#x3D;(n!)^2$$</p><p>对于任意一个 $x,y$ 满足给定条件的，一定对应着一种 $(n!-x)(n!-y)$ 的乘积方式，也就一定对应着 $(n!)^2$ 的一种分解方式。即每一种 $a,b\in \N$ 使得 $a\times b&#x3D;(n!)^2$，就对应着唯一一组 $x,y$ 满足 $x&#x3D;n!-a, y&#x3D;n!-b$，也就对应着一组解。而行相对应的，一个 $a$ 就能得到唯一一个 $b&#x3D;\frac{(n!)^2}{a}$，因此对于每一个 $a|n$ 都能得到一个整数对 $x,y$ 作为一组解。</p><p>于是问题就转化成了 $(n!)^2$ 有多少个因子。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>设 $n!&#x3D;\prod p_i^{\alpha_i}$，那么 $(n!)^2&#x3D;\prod p_i^{2\times \alpha_i}$，最后的答案就是 $\prod(2\times \alpha_i+1)$。</p><p>于是很自然地想到线性筛出 $n$ 以内的指数作为唯一分解定理中的 $p_i$，在指数上，每隔 $p_i$ 就能够乘一次 $p_i$，而每隔 $p_i^2$ 个数 $p_i$ 又能被多乘一次，因此指数上就是</p><p>$$\sum_{j&#x3D;1}^{p_i^j\le n}\frac{n}{p_i^j}$$</p><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,p[N],cnt,ans=<span class="number">1</span>,a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prime</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!p[i])p[++cnt]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;p[j]*i&lt;=n;++j)&#123;</span><br><span class="line">p[p[j]*i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%p[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n; <span class="built_in">prime</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=p[i];j&lt;=n;j=j*p[i])a[i]+=n/j;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)</span><br><span class="line">ans=ans*(<span class="number">2</span>*a[i]+<span class="number">1</span>)%MOD;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;P1445-Violet-樱花-题解&quot;&gt;&lt;a href=&quot;#P1445-Violet-樱花-题解&quot; class=&quot;headerlink&quot; title=&quot;P1445 [Violet] 樱花 题解&quot;&gt;&lt;/a&gt;P1445 [Violet] 樱花 题解&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
    <category term="题解笔记" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Tree 题解</title>
    <link href="http://example.com/2024/07/01/Tree/"/>
    <id>http://example.com/2024/07/01/Tree/</id>
    <published>2024-07-01T13:30:21.000Z</published>
    <updated>2024-07-01T13:31:34.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tree-CF1111E"><a href="#Tree-CF1111E" class="headerlink" title="Tree (CF1111E)"></a>Tree (CF1111E)</h1><h2 id="Des"><a href="#Des" class="headerlink" title="Des"></a>Des</h2><p>给定一棵树和若干次询问。每次询问有若干个数，前三个为 $k,m,r$ 分别表示节点数量，分组数量和根节点。即选中树上的 $k$ 个节点，在 $r$ 为根的情况下至多分成 $m$ 组有多少种分法，要求每个组内不能出现祖先关系。</p><p>其中 $\sum k\le 10^5, m\le 300$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>是不是一眼虚树，但其实完全没必要。考虑动态规划。我们发现一个点能分到哪几个组里只与它有多少个关键节点祖先有关。因此，我们可以假设我们已经知道了它有多少个祖先，并且都做完了这些祖先的动态规划，然后试着转移当前节点。</p><p>因为 $m$ 很小，所以我们完全可以设成二维的状态 $f_{i,j}$ 表示前 $i$ 个点分成 $j$ 组的方案数。那么一个点可以分到原来的组里面，也可以自己一个组。而它不能分到祖先在的组里面。因此，我们设 $s(u)$ 表示 $u$ 有多少个关键节点祖先，那么很容易得到转移方程：</p><p>$$f_{i,j} &#x3D; \max{ j - s(i), 0}\times f_{i-1, j} + f_{i-1, j-1}$$</p><p>然后就可以考虑如何先计算祖先。我们发现可以提前把点按照 $dfn$ 排序，这样就一定能够保证祖先在 $u$ 之前就被处理到。但是每一次的根节点不一样，因此我们可以考虑先计算出 $s(u)$，这样 $s(u)$ 小的一定是大的的祖先。那么 $s(u)$ 使用树剖求 $(r, u)$ 路径上的关键节点数量即可。复杂度 $O(n\log^2n +nm)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,PII&gt; PIII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">3e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,q,m,k,r;</span><br><span class="line"><span class="type">int</span> a[N], s[N], f[N][M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT&#123;</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123; <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))b[i]+=k;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="type">int</span> ans=<span class="number">0</span>; <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))ans+=b[i]; <span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> lowbit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cut&#123;</span><br><span class="line"><span class="type">int</span> dfn[N], rk[N], top[N], siz[N], son[N], dep[N], fa[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fat)</span></span>&#123;</span><br><span class="line">fa[x] = fat, siz[x] = <span class="number">1</span>, dep[x] = dep[fat]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y:g[x])&#123;</span><br><span class="line"><span class="keyword">if</span>(y==fat)<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(y,x);</span><br><span class="line">siz[x]+=siz[y];</span><br><span class="line"><span class="keyword">if</span>(siz[y]&gt;siz[son[x]])son[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">top[x] = tp, dfn[x] = ++idx, rk[idx] = x;</span><br><span class="line"><span class="keyword">if</span>(son[x])<span class="built_in">dfs2</span>(son[x], tp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y:g[x])</span><br><span class="line"><span class="keyword">if</span>(y!=son[x] &amp;&amp; y!=fa[x])<span class="built_in">dfs2</span>(y, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[x] != top[y])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line"><span class="comment">// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;top[x]&lt;&lt;endl;</span></span><br><span class="line">ans += BIT::<span class="built_in">query</span>(dfn[x]) - BIT::<span class="built_in">query</span>(dfn[top[x]]<span class="number">-1</span>);</span><br><span class="line">x = fa[top[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[x]&lt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line"><span class="comment">// cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">return</span> ans + BIT::<span class="built_in">query</span>(dfn[x]) - BIT::<span class="built_in">query</span>(dfn[y]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>, x, y; i&lt;=n; ++i)cin&gt;&gt;x&gt;&gt;y, g[x].<span class="built_in">pb</span>(y), g[y].<span class="built_in">pb</span>(x);</span><br><span class="line">cut::<span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), cut::<span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line">cin&gt;&gt;k&gt;&gt;m&gt;&gt;r;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)cin&gt;&gt;a[i], BIT::<span class="built_in">update</span>(cut::dfn[a[i]], <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)s[i] = cut::<span class="built_in">query</span>(a[i], r) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// for(int i=1;i&lt;=k;++i)cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line"><span class="built_in">sort</span>(s+<span class="number">1</span>, s+<span class="number">1</span>+k);</span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i&lt;=k; ++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>, _end = <span class="built_in">min</span>(i, m); j&lt;=_end; ++j)</span><br><span class="line">f[i][j] = (<span class="built_in">max</span>(j-s[i], <span class="number">0ll</span>) * f[i<span class="number">-1</span>][j] % MOD + f[i<span class="number">-1</span>][j<span class="number">-1</span>]) % MOD;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)ans = (ans + f[k][i]) % MOD;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)BIT::<span class="built_in">update</span>(cut::dfn[a[i]], <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tree-CF1111E&quot;&gt;&lt;a href=&quot;#Tree-CF1111E&quot; class=&quot;headerlink&quot; title=&quot;Tree (CF1111E)&quot;&gt;&lt;/a&gt;Tree (CF1111E)&lt;/h1&gt;&lt;h2 id=&quot;Des&quot;&gt;&lt;a href=&quot;#Des&quot; c</summary>
      
    
    
    
    
    <category term="题解笔记" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>平衡树</title>
    <link href="http://example.com/2024/07/01/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <id>http://example.com/2024/07/01/%E5%B9%B3%E8%A1%A1%E6%A0%91/</id>
    <published>2024-07-01T13:30:21.000Z</published>
    <updated>2024-07-01T13:31:23.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>我一般写二叉搜索树&#x2F;平衡树的时候习惯用指针来写。它可以做到纯动态内存，但是同样的，写的时候会增加很多不必要的麻烦。比如说每次需要判断当前的指针是不是 <code>null</code>。下面介绍一些指针需要用到的基本操作：</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>很常见的一个错误的定义方式是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node* ls, rs;</span><br></pre></td></tr></table></figure><p>这里的 <code>*</code> 是修饰 <code>ls</code> 的，而非 <code>node</code>。因此，定义的时候应写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node *ls, *rs;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node *son[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>对于结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    node *son[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> siz, cnt, val, key;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用 <code>root</code> 中的 <code>val</code> 应写成 <code>root-&gt;val</code> 而非 <code>root.val</code>，一般的，它也可以嵌套使用，比如 <code>root-&gt;son[0]-&gt;siz</code>。</p><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><p>在 <code>pointer</code> 类型中，判空的方法是 <code>root == nullptr</code>，或者 <code>root == NULL</code>。我习惯性写上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> null nullptr</span></span><br></pre></td></tr></table></figure><p>来简化代码。</p><h3 id="新建指针"><a href="#新建指针" class="headerlink" title="新建指针"></a>新建指针</h3><p>因为要做到完全动态，所以内存就需要不断地申请和释放。于是申请内存就可以在结构体内定义一个初始化函数 <code>node</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    node *son[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> siz, val, cnt, key;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> val): <span class="built_in">siz</span>(<span class="number">1</span>), <span class="built_in">cnt</span>(<span class="number">1</span>), <span class="built_in">val</span>(val)&#123; key=<span class="built_in">rand</span>(), son[<span class="number">0</span>]=son[<span class="number">1</span>]=null; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，在定义的时候就只需要：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newnode = <span class="keyword">new</span> <span class="built_in">node</span>(val);</span><br></pre></td></tr></table></figure><h3 id="删除指针"><a href="#删除指针" class="headerlink" title="删除指针"></a>删除指针</h3><p>这里如果我们需要删除一个 <code>root</code>，类型为 <code>node*</code>，则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> root, root = null;</span><br></pre></td></tr></table></figure><p>注意第二个语句不能省略，否则在某些情况下可能会导致错误。</p><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p><code>tuple</code> 是 <code>pair</code> 的一个拓展，是真正的多元变量。即它可以表示一个 $n$ 元组 $(x_1,x_2,\dots,x_n)$。使用方法和 <code>pair</code> 差不多，如由 <code>double double string</code> 组成的三元组可以写成 <code>tuple&lt;double, double, string&gt;</code>。而另一个函数 <code>tie</code> 功能与 <code>make_pair</code> 类似。它可以表示一个 $n$ 元组。如在赋值的时候就可以使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tie</span>(l, mid, r) = <span class="built_in">SplitByRank</span>( root-&gt;son[<span class="number">0</span>], rk);</span><br></pre></td></tr></table></figure><blockquote><p><strong>Warning</strong></p><p>当函数的返回类型为 <code>tuple&lt;&gt;</code> 时，我们不能返回 <code>tie</code> 函数形成的多元组，而应该直接用大括号把所有的元素括起来。如 <code>return &#123;root-&gt;son[0], mid, r&#125;;</code>。</p></blockquote><h2 id="二叉搜索树（Balanced-Search-Tree）"><a href="#二叉搜索树（Balanced-Search-Tree）" class="headerlink" title="二叉搜索树（Balanced Search Tree）"></a>二叉搜索树（Balanced Search Tree）</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>对于一个节点 $p$，如果它的权值为 $val$，它的左儿子的权值小于 $val$，右儿子的权值大于 $val$。</li><li>它的左儿子和右儿子也是二叉搜索树。</li></ul><p>我们称满足这样性质的树叫做二叉搜索树。这其实也就是说，对二叉搜索树进行中序遍历，遍历的结果是单调不降的。</p><p>一般的，一棵二叉搜索树需要维护以下五个信息：</p><ul><li><code>ls</code>，即左儿子，其中 <code>ls-&gt;val &lt; root-&gt;val</code>。</li><li><code>rs</code>，即右儿子，其中 <code>rs-&gt;val &gt; root-&gt;val</code>。</li><li><code>val</code>，即该点的权值。</li><li><code>cnt</code>，即该权值的点的数量。</li><li><code>siz</code>，即当前节点为根的子树的大小。</li></ul><p>如果用指针维护，那么写成 <code>struct</code> 就是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    node *ls, *rs;</span><br><span class="line">    <span class="type">int</span> siz, cnt, val;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> val): <span class="built_in">val</span>(val), <span class="built_in">cnt</span>(<span class="number">1</span>), <span class="built_in">siz</span>(<span class="number">1</span>), <span class="built_in">ls</span>(null), <span class="built_in">rs</span>(null) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设搜索树高度为 $h$，于是可以支持一下操作：</p><h3 id="插入一个数（Insert）"><a href="#插入一个数（Insert）" class="headerlink" title="插入一个数（Insert）"></a>插入一个数（Insert）</h3><p>对于当前根节点 $p$ 和要插入的权值 $val$，我们进行一下操作：</p><ul><li>如果进入空间点，新建一个节点并且值设成 $val$。</li><li>如果 <code>p-&gt;val &gt; val</code>，那么进入 <code>insert(p-&gt;ls, val)</code>。</li><li>如果 <code>p-&gt;val &lt; val</code>，那么进入 <code>insert(p-&gt;rs, val)</code>。</li><li>如果 <code>p-&gt;val == val</code>，那么直接 <code>p-&gt;cnt ++, p-&gt;siz ++</code> 即可。</li></ul><p>其中，修改完之后我们需要一次 <code>push_up</code> 来维护 <code>siz</code>。这个 <code>push_up</code> 可以写在 <code>struct</code> 的里面，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    node *ls, *rs;</span><br><span class="line">    <span class="type">int</span> siz, cnt, val;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> val): <span class="built_in">val</span>(val), <span class="built_in">cnt</span>(<span class="number">1</span>), <span class="built_in">siz</span>(<span class="number">1</span>), <span class="built_in">ls</span>(null), <span class="built_in">rs</span>(null) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">()</span></span>&#123;</span><br><span class="line">        siz=cnt;</span><br><span class="line">        <span class="keyword">if</span>(son[<span class="number">0</span>]!=null)    siz+=son[<span class="number">0</span>]-&gt;siz;</span><br><span class="line">        <span class="keyword">if</span>(son[<span class="number">1</span>]!=null)    siz+=son[<span class="number">1</span>]-&gt;siz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Warning</strong></p><p>注意这里每一次加之前需要判断是否为空节点。</p></blockquote><p>具体地，我们代码可以写成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(node *&amp;root, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==null)  <span class="keyword">return</span> (<span class="type">void</span>)(root = <span class="keyword">new</span> <span class="built_in">node</span>(val));</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val==val)  <span class="keyword">return</span> (<span class="type">void</span>)(root-&gt;siz++ ,root-&gt;cnt++);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&lt;val)  <span class="built_in">insert</span>(root-&gt;rs, val);</span><br><span class="line">    <span class="keyword">else</span>    <span class="built_in">insert</span>(root-&gt;ls, val);</span><br><span class="line">    root-&gt;<span class="built_in">push_up</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除（Delete）"><a href="#删除（Delete）" class="headerlink" title="删除（Delete）"></a>删除（Delete）</h3><p>与插入类似，只是需要判断是否需要 <code>delete</code> 掉当前节点，另外如果需要 <code>delete</code>，那么还需要判断删掉当前节点之后剩下的树的结构怎么办。</p><p>其中，如果当前节点需要被删除，做以下讨论：</p><ul><li>若果该节点的 左&#x2F;右 儿子是空的，我们直接把 右&#x2F;左 儿子作为当前节点即可。</li><li>否则，寻找 左儿子中最大的节点&#x2F;右儿子中最小的节点 作为当前的根。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">remove</span><span class="params">(node *root, <span class="type">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==null)<span class="keyword">return</span> null;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;key&gt;value)root-&gt;ls=<span class="built_in">remove</span>(root-&gt;ls, value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;key&lt;value)root-&gt;rs=<span class="built_in">remove</span>(root-&gt;rs, value);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;count&gt;<span class="number">1</span>)--root-&gt;count;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;ls==null)&#123;</span><br><span class="line">node *tmp = root-&gt;rs;</span><br><span class="line"><span class="keyword">delete</span> root; <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;rs==null)&#123;</span><br><span class="line">node *tmp = root-&gt;ls;</span><br><span class="line"><span class="keyword">delete</span> root; <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">node *tmp = <span class="built_in">FindMin</span>(root-&gt;rs);</span><br><span class="line">root-&gt;key=tmp-&gt;key, root-&gt;count=tmp-&gt;count;</span><br><span class="line">root-&gt;rs=<span class="built_in">remove</span>(root-&gt;rs,tmp-&gt;key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">push_up</span>(root);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据排名查数值（Get-Value-By-Rank）"><a href="#根据排名查数值（Get-Value-By-Rank）" class="headerlink" title="根据排名查数值（Get Value By Rank）"></a>根据排名查数值（Get Value By Rank）</h3><p>这个跟线段树很类似，就是分别判断在 左儿子&#x2F;当前节点&#x2F;右儿子 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> size(x) (x==null?0:x-&gt;siz)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetValueByRank</span><span class="params">(node *root, <span class="type">int</span> rk)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==null)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(rk&lt;=<span class="built_in">size</span>(root-&gt;son[<span class="number">0</span>]))  <span class="keyword">return</span> <span class="built_in">GetValueByRank</span>(root-&gt;son[<span class="number">0</span>], rk);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rk&lt;=<span class="built_in">size</span>(root-&gt;son[<span class="number">0</span>])+root-&gt;cnt)   <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="built_in">GetValueByRank</span>(root-&gt;son[<span class="number">1</span>], rk-<span class="built_in">size</span>(root-&gt;son[<span class="number">0</span>])-root-&gt;cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据数值查排名（Get-Rank-By-Value）"><a href="#根据数值查排名（Get-Rank-By-Value）" class="headerlink" title="根据数值查排名（Get Rank By Value）"></a>根据数值查排名（Get Rank By Value）</h3><p>这个也是根据 <code>BST</code> 的性质做就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetRankByValue</span><span class="params">(node *root, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==null)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(val==root-&gt;val)  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(val&gt;root-&gt;val)<span class="keyword">return</span> <span class="built_in">GetRankByValue</span>(root-&gt;son[<span class="number">1</span>], val) + <span class="built_in">size</span>(root-&gt;son[<span class="number">0</span>]) + root-&gt;cnt;</span><br><span class="line"><span class="keyword">else</span><span class="keyword">return</span> <span class="built_in">GetRankByValue</span>(root-&gt;son[<span class="number">0</span>], val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h1><p>不难看出，我们上述讲的所有的操作复杂度都是 $O(h)$。但是，如果树退化成一根链，我们每一次的复杂度就都变成了 $O(n)$，这显然是不能够满足我们的。因此，我们需要一些操作，在满足 $\text{BST}$ 的性质的同时，使得它最 <strong>平衡</strong>。也就是说，我们需要进行一些操作，使得它最终的形态接近于完全二叉树。这样，我们就能够使得深度在 $O(\log n)$，进而保证时间复杂度正确。</p><h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><p>$\text{Treap}$，即为 $\text{Tree}$ 和 $\text{Heap}$ 的结合。我们在 $\text{BST}$ 的基础上，给每一个节点一个关键字 $key$ 用于存储它在该堆上的值的大小。也就是说，$\text{Treap}$ 不仅要满足 $\text{BST}$ 的性质，同时仍然对于关键字 $\text{key}$ 要满足堆的性质。而如果我们对于每一个节点随机生成一个 $\text{key}$，则有证明可以保证堆的深度期望是在 $O(\log n)$ 的。</p><h3 id="有旋-text-Treap"><a href="#有旋-text-Treap" class="headerlink" title="有旋 $\text{Treap}$"></a>有旋 $\text{Treap}$</h3><p>在 <strong>有旋 $\text{Treap}$</strong> 中，我们通过 <strong>旋转（$\text{Rotate}$）</strong> 来维护堆的性质。</p><p>具体地，它又分为 <strong>左旋（zag）</strong> 和 <strong>右旋（zig）</strong>。</p><h4 id="构建结构体"><a href="#构建结构体" class="headerlink" title="构建结构体"></a>构建结构体</h4><p>根据上述，我们需要的是一个值 <code>val</code>，一个关键字 <code>key</code>，大小 <code>siz</code> 和当前数的数量 <code>cnt</code>。同时，我们需要记录左儿子 <code>ls</code> 和右儿子 <code>rs</code>。于是结构台就是下面这个样子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">node *son[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> siz, cnt, val, key;</span><br><span class="line"><span class="built_in">node</span>(<span class="type">int</span> val): <span class="built_in">val</span>(val), <span class="built_in">siz</span>(<span class="number">1</span>), <span class="built_in">cnt</span>(<span class="number">1</span>), <span class="built_in">key</span>(<span class="built_in">rand</span>())&#123;</span><br><span class="line">son[<span class="number">0</span>] = son[<span class="number">1</span>] = null;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">()</span></span>&#123;</span><br><span class="line">siz=cnt;</span><br><span class="line"><span class="keyword">if</span>(son[<span class="number">0</span>]!=null)siz+=son[<span class="number">0</span>]-&gt;siz;</span><br><span class="line"><span class="keyword">if</span>(son[<span class="number">1</span>]!=null)siz+=son[<span class="number">1</span>]-&gt;siz;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p>如图所示：</p><p><img src="/BT.png"></p><p>左边的图右旋之后变成了右边的图，右边的图左旋之后变成了左边的图。</p><p>其实，这里不难发现，我们 左&#x2F;右 旋转无非就是把原来的祖先变成儿子，儿子变成祖先，这样就可以保证我们维护了堆的性质，进而保证了树的时间复杂度的正确性。具体地，因为两种旋转操作的操作非常类似，所以我们可以直接封装到一个函数里面：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rotate</span><span class="params">(node *&amp; root, <span class="type">bool</span> type)</span></span>&#123; <span class="comment">//右旋为0，左旋为1</span></span><br><span class="line">node *tmp = root-&gt;son[type];</span><br><span class="line">root-&gt;son[type] = tmp -&gt; son[!type], tmp-&gt;son[!type] = root;</span><br><span class="line">root -&gt; <span class="built_in">push_up</span>(), tmp -&gt; <span class="built_in">push_up</span>();</span><br><span class="line">root = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul><li>如果进入空节点，直接新建一个节点。</li><li>如果当前节点的值等于插入的值，该节点的数的数量加一。</li><li>否则，进入 左&#x2F;右 儿子继续查询。</li></ul><p>其中，值得注意的是在查入完之后要注意维护堆的结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(node *&amp;root, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==null)<span class="keyword">return</span> (<span class="type">void</span>)(root = <span class="keyword">new</span> <span class="built_in">node</span>(val));</span><br><span class="line"><span class="keyword">if</span>(val==root-&gt;val)<span class="keyword">return</span> (<span class="type">void</span>)(++root-&gt;cnt, ++root-&gt;siz);</span><br><span class="line"><span class="keyword">if</span>(val&lt;root-&gt;val)&#123;</span><br><span class="line"><span class="built_in">Insert</span>(root-&gt;son[<span class="number">0</span>], val);</span><br><span class="line"><span class="keyword">if</span>(root-&gt;son[<span class="number">0</span>]-&gt;key&lt;root-&gt;key)<span class="built_in">Rotate</span>(root, <span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(val&gt;root-&gt;val)&#123;</span><br><span class="line"><span class="built_in">Insert</span>(root-&gt;son[<span class="number">1</span>], val);</span><br><span class="line"><span class="keyword">if</span>(root-&gt;son[<span class="number">1</span>]-&gt;key&lt;root-&gt;key)<span class="built_in">Rotate</span>(root, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">root-&gt;<span class="built_in">pushup_siz</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>与插入大同小异，唯一需要注意的是要大力分讨删除的节点的儿子状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(node *&amp;root, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(val&gt;root-&gt;val)<span class="built_in">Delete</span>(root-&gt;son[<span class="number">1</span>], val);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(val&lt;root-&gt;val)<span class="built_in">Delete</span>(root-&gt;son[<span class="number">0</span>], val);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;cnt&gt;<span class="number">1</span>)<span class="built_in">return</span> (<span class="type">void</span>)(root-&gt;cnt--, root-&gt;siz--);</span><br><span class="line"><span class="type">bool</span> fl=root-&gt;son[<span class="number">0</span>]!=null;</span><br><span class="line"><span class="type">bool</span> fr=root-&gt;son[<span class="number">1</span>]!=null;</span><br><span class="line">node *tmp = root;</span><br><span class="line"><span class="keyword">if</span>(!fl&amp;&amp;!fr)<span class="keyword">return</span> (<span class="type">void</span>)(<span class="keyword">delete</span> root, root=null);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(fl&amp;&amp;!fr)root=tmp-&gt;son[<span class="number">0</span>], <span class="keyword">delete</span> tmp;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!fl&amp;&amp;fr)root=tmp-&gt;son[<span class="number">1</span>], <span class="keyword">delete</span> tmp;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">bool</span> type = root-&gt;son[<span class="number">0</span>]-&gt;key &lt; root-&gt;son[<span class="number">1</span>]-&gt;key ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Rotate</span>(root, type), <span class="built_in">Delete</span>(root-&gt;son[!type], val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">root-&gt;<span class="built_in">pushup_siz</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询前驱后继"><a href="#查询前驱后继" class="headerlink" title="查询前驱后继"></a>查询前驱后继</h4><p>我们以查询前驱为例子，在查询值小于等于根节点的值的时候，我们不断往左儿子跳，否则跳右儿子，并且记录下来当前的值。最后记录下来的值一定就是前驱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pretmp, suftmp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindPre</span><span class="params">(node *root, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;root-&gt;val&lt;&lt;&quot; &quot;&lt;&lt;val&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(val&lt;=root-&gt;val)&#123;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;son[<span class="number">0</span>]!=null)<span class="keyword">return</span> <span class="built_in">FindPre</span>(root-&gt;son[<span class="number">0</span>], val);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;&quot;QAQ&quot;&lt;&lt;endl;</span></span><br><span class="line">pretmp = root-&gt;val;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;son[<span class="number">1</span>]!=null)<span class="built_in">FindPre</span>(root-&gt;son[<span class="number">1</span>], val);</span><br><span class="line"><span class="keyword">return</span> pretmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindSuf</span><span class="params">(node *root, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(val&gt;=root-&gt;val)&#123;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;son[<span class="number">1</span>]!=null)<span class="keyword">return</span> <span class="built_in">FindSuf</span>(root-&gt;son[<span class="number">1</span>], val);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">suftmp = root-&gt;val;</span><br><span class="line"><span class="keyword">if</span>(root-&gt;son[<span class="number">0</span>])<span class="built_in">FindSuf</span>(root-&gt;son[<span class="number">0</span>], val);</span><br><span class="line"><span class="keyword">return</span> suftmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无旋-text-Treap"><a href="#无旋-text-Treap" class="headerlink" title="无旋 $\text{Treap}$"></a>无旋 $\text{Treap}$</h3><p>在 <strong>无旋 $\text{Treap}$</strong> 中，我们通过 <strong>分裂（$\text{Split}$）</strong> 和 <strong>合并（$\text{Merge}$）</strong> 两种操作来维护堆的结构。</p><h4 id="分裂（Split）"><a href="#分裂（Split）" class="headerlink" title="分裂（Split）"></a>分裂（Split）</h4><p>分裂分为 <strong>按值分裂</strong> 和 <strong>按大小分裂</strong> 两种。</p><p>先介绍按值分裂。</p><p>这里，<strong>分裂</strong> 的意思就是把 $\le val$ 的分裂成一棵平衡树，而 $&gt;val$ 的分到另一棵。很明显，在进入一棵子树 $root$ 时，要做如下判断：</p><ul><li>如果 <code>root-&gt;val&lt;=val</code>，则显然，该子树的左子树都小于 $val$，因此我们只需要进入右子树继续递归即可，但注意右子树可能仍然有小于 <code>val</code> 的。</li><li>如果 <code>root-&gt;val&gt;val</code>，则说明该子树右子树都大于 <code>val</code>，直接进入左子树继续递归即可。但注意左子树可能仍然有大于 $val$ 的。</li></ul><p>如果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉搜索树&quot;&gt;&lt;a href=&quot;#二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树&quot;&gt;&lt;/a&gt;二叉搜索树&lt;/h1&gt;&lt;h2 id=&quot;指针&quot;&gt;&lt;a href=&quot;#指针&quot; class=&quot;headerlink&quot; title=&quot;指针&quot;&gt;&lt;/a&gt;指</summary>
      
    
    
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>树上染色 题解</title>
    <link href="http://example.com/2024/07/01/%E6%A0%91%E4%B8%8A%E6%9F%93%E8%89%B2/"/>
    <id>http://example.com/2024/07/01/%E6%A0%91%E4%B8%8A%E6%9F%93%E8%89%B2/</id>
    <published>2024-07-01T13:30:21.000Z</published>
    <updated>2024-07-01T13:31:48.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="F-树上染色"><a href="#F-树上染色" class="headerlink" title="F - 树上染色"></a>F - 树上染色</h1><h2 id="Des"><a href="#Des" class="headerlink" title="Des"></a>Des</h2><p>给定一棵树，要求在树上把 $m$ 个点染成黑色，并有价值函数</p><p>$$v(E’) &#x3D; \sum_{v_1,v_2\in E’} dis(v_1,v_2) + \sum_{v_1,v_2\in E-E’} dis(v_1,v_2)$$</p><p>求一种染色方式使得最大化 $v(E’)$。</p><h2 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h2><p>仍然考虑动态规划。</p><p>$f_{u,k}$ 表示 $u$ 子树内选择 $k$ 个 <strong>对答案的贡献</strong>。考虑这和 $f_{u,k}$ 表示 $u$ 子树内选择 $k$ 个 <strong>的价值</strong> 有什么不同。</p><p>对于答案的贡献，我们是默认在 $u$ 子树之外已经选择了 $m-k$ 个其他的黑色节点的，因此对于边 $u\to v$，若有 $v$ 子树内已经选择了 $k$ 个，那么边 $u\to v$ 经过的次数就是 $k\times(m-k)$ 次，因此对答案的贡献就是 $w\times k\times (m-k)$。同理可以计算得到白点的贡献。</p><p>而价值指的是 $u$ 子树内选择 $k$ 个，而 $v$ 子树内选择 $k’$ 个的贡献，这是不好被统计的。</p><p>由第一个设的状态，我们有转移方程：</p><p>$$f_{u,j} &#x3D; \max{f_{v,k} + f_{u,j-k} + w\times k\times (m-k) + w\times (sz_v-k)\times (n-m-sz_v+k)}$$</p><p>但是这样显然会 $\text{TLE}$。这是因为我们需要 $DFS$，并且每个点枚举一个 $j$ 和一个 $k$，复杂度 $O(nk^2)$。无法接受。</p><p>我们做一个上下界优化。显然，$j$ 的上下界是 $[0,\min(m,sz_u)]$，其中 $u$ 是已经遍历到的 $u$ 子树的大小。而 $k$ 的范围是 $[\max(j-sz_u+sz_v,0),\min(sz_v,m)]$。因此，式子就变成了：</p><p>$$f_{u,j} &#x3D; \max_{j&#x3D;0}^{\min(m,sz_u)}\max_{k&#x3D;\max(j-sz_u+sz_v,0)}^{\min(sz_v,m)}{f_{v,k} + f_{u,j-k} + w\times k\times (m-k) + w\times (sz_v-k)\times (n-m-sz_v+k)}$$</p><p>为啥复杂度是对的前几篇题解写得也已经很明确了。这里需要注意的是 $j$ 需要倒序枚举，否则答案会不正确。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DBG cerr &lt;&lt; __LINE__ &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; __FUNCTION__ &lt;&lt; endl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRE default_random_engine</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UID uniform_int_distribution</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y0 Y0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y1 Y1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eps (1e-8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> null nullptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,PII&gt; PIII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">5e2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N], n, m, siz[N];</span><br><span class="line">vector&lt;PII&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">siz[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(PII y:g[x])&#123;</span><br><span class="line"><span class="keyword">if</span>(y.fi == fa)  <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">solve</span>(y.fi, x);</span><br><span class="line">siz[x] += siz[y.fi];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="built_in">max</span>(siz[x], m); j&gt;=<span class="number">0</span>; --j)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="built_in">max</span>(j - siz[x] + siz[y.fi], <span class="number">0ll</span>); k &lt;= <span class="built_in">min</span>(j, siz[y.fi]); ++k)</span><br><span class="line">f[x][j] = <span class="built_in">max</span>(f[x][j], f[y.fi][k] + f[x][j-k] + y.se * k * (m-k) + y.se * (siz[y.fi]-k) * (n-m-siz[y.fi]+k));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y,z;i&lt;n;++i)  cin&gt;&gt;x&gt;&gt;y&gt;&gt;z, g[x].<span class="built_in">pb</span>(<span class="built_in">mk</span>(y,z)), g[y].<span class="built_in">pb</span>(<span class="built_in">mk</span>(x,z));</span><br><span class="line"><span class="built_in">solve</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;f[<span class="number">1</span>][m]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;F-树上染色&quot;&gt;&lt;a href=&quot;#F-树上染色&quot; class=&quot;headerlink&quot; title=&quot;F - 树上染色&quot;&gt;&lt;/a&gt;F - 树上染色&lt;/h1&gt;&lt;h2 id=&quot;Des&quot;&gt;&lt;a href=&quot;#Des&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="题解笔记" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Trailing Loves 题解</title>
    <link href="http://example.com/2024/07/01/Trailing%20Loves/"/>
    <id>http://example.com/2024/07/01/Trailing%20Loves/</id>
    <published>2024-07-01T13:29:21.000Z</published>
    <updated>2024-07-01T13:30:03.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Trailing-Loves"><a href="#Trailing-Loves" class="headerlink" title="Trailing Loves"></a>Trailing Loves</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个数 $n$ 求 $n!$ 在 $b$ 进制下末尾 0 的个数。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>很容易想到的是 $n!$ 中有多少个因子 $b$ 就能在末尾产生多少个 0。那么假设</p><p>$$b&#x3D;\prod_{i&#x3D;1}^{k} p_i^{\alpha_i}，n!&#x3D;\prod_{j&#x3D;1}^{m} p_j^{\beta_j}$$</p><p>那么我们就只需要一一对应 $b$ 含有的质因子，取</p><p>$$\min_{i&#x3D;1}^k{\frac{\beta_i}{\alpha_i}}$$</p><p>为答案即可。</p><p>其中 $n!$ 的因子 $p_j$ 的指数可以表示为</p><p>$$\beta_j&#x3D;\sum_{i&#x3D;1}^{p_i\le n}\frac{n}{p^i}$$</p><h2 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,b,p[N],minn=INF,cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> m=n;</span><br><span class="line"><span class="keyword">while</span>(m)    ans+=m/x, m/=x;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;b;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=b;++i)&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(b%i==<span class="number">0</span>)++sum, b/=i;</span><br><span class="line"><span class="keyword">if</span>(sum==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">minn=<span class="built_in">min</span>(minn,<span class="built_in">fun</span>(i)/sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b!=<span class="number">1</span>)minn=<span class="built_in">min</span>(minn,<span class="built_in">fun</span>(b));</span><br><span class="line">cout&lt;&lt;minn&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Trailing-Loves&quot;&gt;&lt;a href=&quot;#Trailing-Loves&quot; class=&quot;headerlink&quot; title=&quot;Trailing Loves&quot;&gt;&lt;/a&gt;Trailing Loves&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot;</summary>
      
    
    
    
    
    <category term="题解笔记" scheme="http://example.com/tags/%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/06/19/6.15%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2024/06/19/6.15%E9%A2%98%E8%A7%A3/</id>
    <published>2024-06-19T14:54:52.850Z</published>
    <updated>2024-06-18T13:43:52.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-15-题解"><a href="#6-15-题解" class="headerlink" title="6.15 题解"></a>6.15 题解</h1><h2 id="A-星际蛋糕推销"><a href="#A-星际蛋糕推销" class="headerlink" title="A - 星际蛋糕推销"></a>A - 星际蛋糕推销</h2><h3 id="Des"><a href="#Des" class="headerlink" title="Des"></a>Des</h3><p>你有 $n$ 个数，我们希望这 $n$ 个数都是奇数。因此，我们每一次会对于最左边的一个偶数进行减半操作，即把 $a_i$ 变成两个 $\frac{a_i}{2}$ 并放在原位置上。完成操作后求有 $m$ 个询问求第 $i$ 个位置是什么。</p><h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>显然，若将 $a_i$ 质因数分解，则有：</p><p>$$a_i &#x3D; \prod_{p\in \mathcal{P}} p_i^{\alpha_i}$$</p><p>其中 $p_1&#x3D;2$，因此它会被切 $2^{\alpha_1}$ 次。这样，我们就能够知道每一个数会被分成多少个数，维护一个前缀和表示每个数产生的数截止到哪里，然后每一次二分查找答案即可。复杂度 $O(n\log n)$。</p><h2 id="B-狡猾的商人"><a href="#B-狡猾的商人" class="headerlink" title="B - 狡猾的商人"></a>B - 狡猾的商人</h2><h3 id="Des-1"><a href="#Des-1" class="headerlink" title="Des"></a>Des</h3><p>给定 $m$ 次询问并告诉你答案。具体的，每一次询问形如 $l,r,s$，表示 $\sum\limits_{i&#x3D;l}^ra_i&#x3D;s$。你需要判断存不存在数列 $a_i$ 满足条件。</p><h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol"></a>Sol</h3><p>让我们把询问写成前缀和的形式。具体的，对于询问 $l,r,s$，我们有 $s_r-s_{l-1} &#x3D; s$。也就是说，从 $l-1\to r$ 经过了 $s$ 才能到达。这个东西我们考虑建图，那么它们合法当且仅当图上的环都自洽。也就是说，如果有 $u\to x$ 权值为 $a$，$x\to v$ 权值为 $b$，则一定有 $u\to v$ 权值为 $a+b$。</p><p>具体的，对于询问 $l,r,s$，我们建立边 $(l-1, r, s)$ 和 $(r, l-1, -s)$，然后跑一遍 $\text{Floyd}$ 传递闭包，如果某一条边不存在就更新，否则就判断是否有 <code>ma[i][j] = ma[i][k] + ma[k][j]</code>。</p><p>（听说这个题还有 $O(n·\alpha(n))$ 的并查集做法，但是 $100$ 的 $n$ 为什么不跑一个简单优美的 $\text{Floyd}$ 呢&#x2F;doge）</p><h2 id="C-字串距离"><a href="#C-字串距离" class="headerlink" title="C - 字串距离"></a>C - 字串距离</h2><h3 id="Des-2"><a href="#Des-2" class="headerlink" title="Des"></a>Des</h3><p>对于两个字符串 $s_1$，$s_2$，我们可以在任意地方补足任意的空格，使得最终的两个字符串长度相等。这样，我们有代价的公式：</p><p>$$\sum_{i&#x3D;1}^{len} |s1_i-s2_i|$$</p><p>其中若 $s1_i$ 或 $s2_i$ 为空格，则规定 $|s1_i-s2_i|&#x3D;k$，而若 $s1_i$ 和 $s2_i$ 都为空格，则有 $|s1_i-s2_i| &#x3D; 0$。</p><h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol"></a>Sol</h3><p>不难想到，我们设 $f_{i,j}$ 表示 $s1$ 进行到 $i$，$s2$ 进行到 $j$ 的最小代价。其中 $f_{i,j}$ 可以由 $f_{i-1,j}$、$f_{i,j-1}$、$f_{i-1,j-1}$ 三个状态转移过来。其中前两个表示分别用空格去匹配别的字符，而第三个表示用 $s1_{i-1}$ 去匹配 $s2_{j-1}$，因此，就有如下转移方程：</p><p>$$f_{i,j} &#x3D; \min{f_{i-1,j}+k, f_{i,j-1}+k,f_{i-1,j-1}+|s1_{i-1}-s2_{j-1}|}$$</p><p>复杂度 $O(n^2)$。</p><h2 id="D-Marvolo-Gaunt’s-Ring"><a href="#D-Marvolo-Gaunt’s-Ring" class="headerlink" title="D - Marvolo Gaunt’s Ring"></a>D - Marvolo Gaunt’s Ring</h2><h3 id="Des-3"><a href="#Des-3" class="headerlink" title="Des"></a>Des</h3><p>给定序列 $a_n$ 和常数 $p,q,r$，求三元组 $(i,j,k)$ 满足 $i\le j\le k$ 且最小化 $pa_i+qa_j+ra_k$。</p><h3 id="Sol-3"><a href="#Sol-3" class="headerlink" title="Sol"></a>Sol</h3><p>维护一个前缀最大、前缀最小、后缀最大、后缀最小。然后枚举中间点 $j$，向前向后分别 $O(1)$ 求出 $pa_i+ra_k$ 的最大值即可。</p><p>注意要根据 $p,r$ 的正负情况分类讨论。</p><h2 id="E-Running-S"><a href="#E-Running-S" class="headerlink" title="E - Running S"></a>E - Running S</h2><h3 id="Des-4"><a href="#Des-4" class="headerlink" title="Des"></a>Des</h3><p>小可喜欢跑步。</p><p>他每天早上疲惫值为 $0$，在第 $i$ 分钟可以跑 $d_i$ 米，会增加 $1$ 的疲惫值。他疲惫值最多为 $m$。同时，他也可以选择休息。但是选择休息就必须休息到 $0$ 疲惫值，其中疲惫值每分钟降低 $1$。同时，在疲惫值为 $0$ 时，他也可以选择啥也不干，并且最终的疲惫值必须为 $0$。问他最多能跑多远。</p><h3 id="Sol-4"><a href="#Sol-4" class="headerlink" title="Sol"></a>Sol</h3><p>考虑动态规划。</p><p>首先我们想到的是 $f_{i,j}$ 表示前 $i$ 分钟疲惫值为 $j$ 时最远能跑多少。那么显然有转移方程：</p><p>$$f_{i,j} &#x3D; f_{i-1,j-1} + d_i, j\not &#x3D; 0$$</p><p>$$f_{i,0} &#x3D; \min\limits_{j&#x3D;i}^{\max(i-m,0)} f_{j,i-j}$$</p><p>方程 $1$ 很好弄，$O(1)$ 直接搞定，但是第二个可能需要复杂度退化一个 $m$，这不能接受。</p><p>我们考虑一种一遍填表一边刷表的方式。也就是当我们转移完 $f_{i,j}(j\not &#x3D; 0)$ 时，我们令 $f_{i+j,0}\leftarrow f_{i,j}$ 即可。这样就保证了复杂度的正确性。</p><h2 id="F-树上染色"><a href="#F-树上染色" class="headerlink" title="F - 树上染色"></a>F - 树上染色</h2><h3 id="Des-5"><a href="#Des-5" class="headerlink" title="Des"></a>Des</h3><p>给定一棵树，要求在树上把 $m$ 个点染成黑色，并有价值函数</p><p>$$v(E’) &#x3D; \sum_{v_1,v_2\in E’} dis(v_1,v_2) + \sum_{v_1,v_2\in E-E’} dis(v_1,v_2)$$</p><p>求一种染色方式使得最大化 $v(E’)$。</p><h3 id="Sol-5"><a href="#Sol-5" class="headerlink" title="Sol"></a>Sol</h3><p>仍然考虑动态规划。</p><p>$f_{u,k}$ 表示 $u$ 子树内选择 $k$ 个 <strong>对答案的贡献</strong>。考虑这和 $f_{u,k}$ 表示 $u$ 子树内选择 $k$ 个 <strong>的价值</strong> 有什么不同。</p><p>对于答案的贡献，我们是默认在 $u$ 子树之外已经选择了 $m-k$ 个其他的黑色节点的，因此对于边 $u\to v$，若有 $v$ 子树内已经选择了 $k$ 个，那么边 $u\to v$ 经过的次数就是 $k\times(m-k)$ 次，因此对答案的贡献就是 $w\times k\times (m-k)$。同理可以计算得到白点的贡献。</p><p>而价值指的是 $u$ 子树内选择 $k$ 个，而 $v$ 子树内选择 $k’$ 个的贡献，这是不好被统计的。</p><p>由第一个设的状态，我们有转移方程：</p><p>$$f_{u,j} &#x3D; \max{f_{v,k} + f_{u,j-k} + w\times k\times (m-k) + w\times (sz_v-k)\times (n-m-sz_v+k)}$$</p><p>但是这样显然会 $\text{TLE}$。这是因为我们需要 $DFS$，并且每个点枚举一个 $j$ 和一个 $k$，复杂度 $O(nk^2)$。无法接受。</p><p>我们做一个上下界优化。显然，$j$ 的上下界是 $[0,\min(m,sz_u)]$，其中 $u$ 是已经遍历到的 $u$ 子树的大小。而 $k$ 的范围是 $[\max(j-sz_u+sz_v,0),\min(sz_v,m)]$。因此，式子就变成了：</p><p>$$f_{u,j} &#x3D; \max_{j&#x3D;0}^{\min(m,sz_u)}\max_{k&#x3D;\max(j-sz_u+sz_v,0)}^{\min(sz_v,m)}{f_{v,k} + f_{u,j-k} + w\times k\times (m-k) + w\times (sz_v-k)\times (n-m-sz_v+k)}$$</p><p>为啥复杂度是对的前几篇题解写得也已经很明确了。这里需要注意的是 $j$ 需要倒序枚举，否则答案会不正确。</p><h2 id="G-LCA"><a href="#G-LCA" class="headerlink" title="G - LCA"></a>G - LCA</h2><h3 id="Des-6"><a href="#Des-6" class="headerlink" title="Des"></a>Des</h3><p>给定一棵树，有 $q$ 次询问，每次询问形如 $l,r,x$，求：</p><p>$$\sum_{i&#x3D;l}^r \operatorname{dep}[\operatorname{lca}(i,x)]$$</p><h3 id="Sol-6"><a href="#Sol-6" class="headerlink" title="Sol"></a>Sol</h3><p>首先，我们想到把 $l,r$ 拆成两个询问，即 ${l-1, -1}$ 和 ${r,1}$，表示答案乘上 $-1&#x2F;1$ 贡献到 $i$ 中。然后使用扫描线扫描当前的到了第几个节点，并且标记好以方便我们进行查询操作。</p><p>于是，现在的问题就是如何进行修改和查询。</p><p>注意到，如果有些点在 $x$ 的子树内，那么它们的 $lca$ 一定是 $x$，也就是贡献 $\operatorname{dep}[x]$。我们记 $s_x$ 表示 $x$ 子树内被标记的点的数量，那么答案一定有 $s_x\times \operatorname{dep}[x]$。</p><p>再往上一层，我们记 $y&#x3D;fa_x$ 表示 $x$ 的父亲，那么显然，对于所有在 $y$ 子树内但不在 $x$ 子树内的节点和 $x$ 的最近公共祖先显然就是 $y$，那么贡献就是 $(s_y-s_x) \times \operatorname{dep}[y]$。再往上一层，记 $z &#x3D; fa_y$，则有贡献 $(s_z-s_y)\times \operatorname{dep}[z]$。全部加起来，就可以得到 $s_x\times \operatorname{dep}[x] + (s_y-s_x)\operatorname{dep}[y]+(s_z-s_y)\operatorname{dep}[z]&#x3D;s_x(\operatorname{dep}[x]-\operatorname{dep}[y])+s_y(\operatorname{dep}[y]-\operatorname{dep[z]})+s_z\operatorname{dep}[z]$，其中 $\operatorname{dep}[x]-\operatorname{dep}[y]&#x3D;\operatorname{dep}[y]-\operatorname{dep}[z]&#x3D;\operatorname{dep}[z]&#x3D;1$，于是式子就是 $s_x+s_y+s_z$。</p><p>通过上面的式子我们不难推出，询问 $x$ 的值就是 $x$ 及 $x$ 所有的父亲的 $s_x$ 之和。换句话说，是 $(1,x)$ 路径上的 $s_x$ 和。</p><p>我们再来看修改会带来什么影响。我们想知道的是每个点的子树中被标记的点的数量，那么对于一个点 $x$，当它加入了树中，他所有的祖先的 $s_x$ 都应该加一。也就是在路径 $(1,x)$ 上区间 $+1$。</p><p>在回头梳理一下解题过程：</p><ul><li>将询问 $l,r,x$ 拆成 $l-1,x,-1$ 和 $r,x,1$。</li><li>从左到右扫描节点，先进行修改再处理询问。</li><li>修改操作使用树剖在 $(1,x)$ 的路径上区间 $+1$。</li><li>查询操作使用树剖求 $(1,x)$ 路径上的区间和。</li></ul><p>使用树剖+线段树即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-15-题解&quot;&gt;&lt;a href=&quot;#6-15-题解&quot; class=&quot;headerlink&quot; title=&quot;6.15 题解&quot;&gt;&lt;/a&gt;6.15 题解&lt;/h1&gt;&lt;h2 id=&quot;A-星际蛋糕推销&quot;&gt;&lt;a href=&quot;#A-星际蛋糕推销&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/06/19/6.13%E9%A2%98%E8%A7%A3/"/>
    <id>http://example.com/2024/06/19/6.13%E9%A2%98%E8%A7%A3/</id>
    <published>2024-06-19T14:54:38.131Z</published>
    <updated>2024-06-19T14:54:18.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="6-13-题解"><a href="#6-13-题解" class="headerlink" title="6.13 题解"></a>6.13 题解</h1><h2 id="D-Glass-Carving"><a href="#D-Glass-Carving" class="headerlink" title="D - Glass Carving"></a>D - Glass Carving</h2><h3 id="Des"><a href="#Des" class="headerlink" title="Des"></a>Des</h3><p>有一个 $w\times h$ 的玻璃每一次可以在 横&#x2F;竖 方向上某一个位置切一刀，求最后的最大的矩形面积。</p><h3 id="Sol"><a href="#Sol" class="headerlink" title="Sol"></a>Sol</h3><p>首先，一个显而易见的结论是，对于横方向和纵方向，我们都取最大值，于是答案就是它们的乘积。</p><p>考虑如何维护横方向和纵方向的最大值。</p><p>因为切刀是在 $(x,x+1)$ 的中间切的，这很不好，因此我们把矩形变成 $(2w-1)\times(2h-1)$ 大小，其中对于 $\forall i \in [1,n)$，第 $2i$ 个位置表示原来 $(i,i+1)$ 的 <strong>缝隙</strong>。这样，我们在修改的时候就可以精确地找到它的位置。</p><p>于是我们使用两只线段树，分别统计横向和纵向的切割情况。初始线段树都设成 $1$，对于一次修改 $x$，我们把 $2x$ 这个地方修改成 $-\infty$，于是最长的长度就是整只线段树的最大子段和。记 $ans$ 是最大子段和，那么它还原回去的最大长度就是 $\frac{ans+1}{2}$。</p><p>当然，你也可以发明一个最长连续 $1$ 的个数，这个东西和最大子段和很像，也不是太难写 <del>（我就是这么写的$QwQ$）</del></p><h2 id="E-树"><a href="#E-树" class="headerlink" title="E - 树"></a>E - 树</h2><h3 id="Des-1"><a href="#Des-1" class="headerlink" title="Des"></a>Des</h3><p>给定一棵树，支持两种操作：</p><ul><li>标记一个点 $x$。</li><li>查询一个点 $x$ 的祖先中，距离 $x$ 最近的被标记的点是哪个。</li></ul><p>其中 $1$ 是根，并且最开始就被标记了。</p><h3 id="Sol-1"><a href="#Sol-1" class="headerlink" title="Sol"></a>Sol</h3><p>这里提供一个很臭的 $n\log^3 n$ 做法。<del>（但是是三个常数很小的 $\log$，因此可以过去。）</del></p><p>首先，如果我们打标记就相当于给节点的权值 $+1$，那么问题就变成了找到 <strong>深度最小的节点使得它到 $x$ 之间没有节点被打标记</strong>，然后输出这个节点的父亲。然后，我们发现，在 $1-x$ 不断向下查找的过程之中，$1-u$ 的标记的点的数量显然是单调不增的。也就是说，如果 $x-u$ 之间存在打标记的点，那么对于 $f &#x3D; fa_u$，显然有 $x-f$ 之间有打标记的点。于是，我们就想到了用倍增来解决这个问题。我们从大到小不断改变二的次幂，凑出一个长度使得 $x-u$ 之间不存在打标记的点。输出 $fa_u$ 即可。</p><p>然后修改就是树上单点修，查询就是树上路径查询，直接剖即可。</p><p>复杂度 $O(n\log ^3 n)$，其中剖和树状数组常数都很小，而倍增是稳定的一个 $\log$。</p><h2 id="F-魔法树"><a href="#F-魔法树" class="headerlink" title="F - 魔法树"></a>F - 魔法树</h2><p>剖的板子，不讲了。</p><h2 id="G-二进制方程"><a href="#G-二进制方程" class="headerlink" title="G - 二进制方程"></a>G - 二进制方程</h2><h3 id="Des-2"><a href="#Des-2" class="headerlink" title="Des"></a>Des</h3><p>有方程形如：</p><p>$$\overline{x_1x_2\dots x_n} &#x3D; \overline{y_1y_2\dots y_n}$$</p><p>其中 $x$ 或 $y$ 的某一些区间会被未知数替代，比如说 $x$ 中的区间 $[3,5]$ 可能会变成 $a$，那么 $a$ 就代表三位二进制数 $\overline{pqr}$。</p><p>若给定一共有多少个未知数、每个未知数占据多少位，求可能的等式的数量。</p><h3 id="Sol-2"><a href="#Sol-2" class="headerlink" title="Sol"></a>Sol</h3><p>我们把两个二进制数拆开来写：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/v667ymag.png"></p><p>如果，我们有 $x[3,5] &#x3D; y[1,3] &#x3D; a$，$x[1,2]&#x3D;y[6,7]&#x3D;b$，则有如下网络关系：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/b017u21j.png"></p><p>也就是有联通块关系如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/yywb8mk0.png"></p><p>有两种联通块，也就是有两种不同的选择，于是答案就是 $2^2$。</p><p>但是我们没有考虑方程中 $0$ 和 $1$ 的情况。也就是说，如果某一个位置，比如 $y_2&#x3D;1$，那么总有 $2,4,7$ 这三个地方都是 $1$，也就是说，它们不能自由选择了。于是这里的答案应该是 $2^1&#x3D;2$。</p><p>因此，我们把 $k$ 个变量展开来，再把 $X$ 和 $Y$ 展开来。设 $i$ 个变量的长度为 $len_i$，我们给 $0,1$ 分配一个位置，给变量 $i$ 分配 $len_i$ 个位置并分别标号。对于 $X$ 和 $Y$ 中的一个位置 $X_i$ 和 $Y_i$，总能对应带我们给出的类似于内存条的东西上的一个位置上，我们把这个东西记录下来，然后在并查集上合并 $X_i$ 和 $Y_i$，最后二的联通块个数次幂就是答案。</p><p>值得注意的是，对于 $0$ 和 $1$ 在一个联通块的情况，总需要输出 $0$。</p><h2 id="H-运输计划"><a href="#H-运输计划" class="headerlink" title="H - 运输计划"></a>H - 运输计划</h2><h3 id="Des-3"><a href="#Des-3" class="headerlink" title="Des"></a>Des</h3><p>给定一棵树，在树上有 $m$ 条路径，其中每一条路径形如 $(u,v)$。要求将其中的一条边 $x\to y$ 边权改成 $0$，使得最小化</p><p>$$\max_{i&#x3D;1}^m dis(u_i,v_i)$$</p><h3 id="Sol-3"><a href="#Sol-3" class="headerlink" title="Sol"></a>Sol</h3><p>首先，一个显而易见的结论是，改变的那条边一定在最长的路径之上，否则，答案一定是那条最长的路径。</p><p>于是我们考虑枚举最长路径上的每一条边。对于一条边 $(u,v,w)$，显然，如果将 $w\leftarrow 0$，则所有的路径可以分为两种。一种是经过边 $(u,v,w)$ 的路径；另一种是不经过边 $(u,v,w)$。其中，经过该边的路径显然都需要把最终的答案减去 $w$，而最长的路径又一定经过该边，因此经过该边的路径的长度最大值就是最长的路径长度减去 $w$。</p><p>然后我们再来讨论没有经过该边的路径。</p><p>首先，我们考虑能不能在线求出，但是显然我们并不能够在能够接受的复杂度之内算出不经过该边的路径有哪些，那我们不妨提前都预处理出来。</p><p>对于一条路径 $(u,v,t)$，其中 $t &#x3D; dis(u,v)$，它不经过的边在计算不经过该边的最大路径长度的时候都会把它计算到，因此我们把这些路径跟 $t$ 取一个 $\max$，这样，在处理完所有路径的时候，每条边的 $\max$ 就是不经过该边的最长路径长度。接下来我们考虑如何快速在一条路径之外取 $\max$。由树剖，我们知道，树上的一条路径可以唯一分解成最多 $\log n$ 条 $dfn$ 连续的链，因此，我们把这些连续的 $dfn$ 段记录下来，然后按照左端点排序，这样我们就得到了一堆按照先后排序的没有交的区间。我们把这些区间在 $[1,n]$ 的全集意义下取反集，就可以知道那些边是会被修改的。</p><p>有的同学会问，我们怎么统计边的信息呢？这就用到了一个方法，把边权放到点上统计。具体地，对于外向边 $x\to y$，我们可以把权值 $z$ 统计到 $y$ 上。也就是说，如果有边 $x\to fa_x$，我们把这条边的信息统计到 $x$ 而不是 $fa_x$ 上。特别地，$1$ 号节点不统计任何信息。</p><p>这样，我们就完成了这道题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;6-13-题解&quot;&gt;&lt;a href=&quot;#6-13-题解&quot; class=&quot;headerlink&quot; title=&quot;6.13 题解&quot;&gt;&lt;/a&gt;6.13 题解&lt;/h1&gt;&lt;h2 id=&quot;D-Glass-Carving&quot;&gt;&lt;a href=&quot;#D-Glass-Carving&quot; c</summary>
      
    
    
    
    
  </entry>
  
</feed>
